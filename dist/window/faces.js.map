{"version":3,"file":"faces.js","mappings":"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","sources":["webpack://jsf.js_next_gen/./node_modules/mona-dish/src/main/typescript/DomQuery.ts","webpack://jsf.js_next_gen/./node_modules/mona-dish/src/main/typescript/Global.ts","webpack://jsf.js_next_gen/./node_modules/mona-dish/src/main/typescript/Lang.ts","webpack://jsf.js_next_gen/./node_modules/mona-dish/src/main/typescript/Monad.ts","webpack://jsf.js_next_gen/./node_modules/mona-dish/src/main/typescript/SourcesCollectors.ts","webpack://jsf.js_next_gen/./node_modules/mona-dish/src/main/typescript/Stream.ts","webpack://jsf.js_next_gen/./node_modules/mona-dish/src/main/typescript/XmlQuery.ts","webpack://jsf.js_next_gen/./node_modules/mona-dish/src/main/typescript/index_core.ts","webpack://jsf.js_next_gen/./src/main/typescript/api/_api.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/AjaxImpl.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/PushImpl.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/core/Const.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/core/ImplTypes.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/i18n/Messages.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/util/Assertions.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/util/AsyncQueue.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/util/ExtDomQuery.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/util/Lang.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/xhrCore/ErrorData.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/xhrCore/EventData.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/xhrCore/RequestDataResolver.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/xhrCore/ResonseDataResolver.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/xhrCore/Response.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/xhrCore/ResponseProcessor.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/xhrCore/XhrFormData.ts","webpack://jsf.js_next_gen/./src/main/typescript/impl/xhrCore/XhrRequest.ts","webpack://jsf.js_next_gen/./src/main/typescript/myfaces/OamSubmit.ts","webpack://jsf.js_next_gen/webpack/bootstrap","webpack://jsf.js_next_gen/webpack/runtime/global","webpack://jsf.js_next_gen/./src/main/typescript/api/faces.ts"],"sourcesContent":["/*!\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Config, Optional, ValueEmbedder} from \"./Monad\";\nimport {XMLQuery} from \"./XmlQuery\";\nimport {IStream, LazyStream, Stream} from \"./Stream\";\nimport {ArrayCollector, ICollector, IStreamDataSource, ITERATION_STATUS} from \"./SourcesCollectors\";\nimport {Lang} from \"./Lang\";\nimport trim = Lang.trim;\nimport objToArray = Lang.objToArray;\nimport isString = Lang.isString;\nimport equalsIgnoreCase = Lang.equalsIgnoreCase;\nimport {_global$} from \"./Global\";\n\ndeclare var ownerDocument: any;\n\n/**\n * in order to poss custom parameters we need to extend the mutation observer init\n */\nexport interface WAIT_OPTS extends MutationObserverInit {\n    timeout?: number;\n    /**\n     * interval on non legacy browsers\n     */\n    interval?: number;\n}\n\n\n/**\n *\n *        // - submit checkboxes and radio inputs only if checked\n if ((tagName != \"select\" && elemType != \"button\"\n && elemType != \"reset\" && elemType != \"submit\" && elemType != \"image\")\n && ((elemType != \"checkbox\" && elemType != \"radio\"\n */\n\nenum Submittables {\n    SELECT = \"select\",\n    BUTTON = \"button\",\n    SUBMIT = \"submit\",\n    RESET = \"reset\",\n    IMAGE = \"image\",\n    RADIO = \"radio\",\n    CHECKBOX = \"checkbox\"\n\n}\n\n/**\n * helper to fix a common problem that a system has to wait, until a certain condition is reached.\n * Depending on the browser this uses either the Mutation Observer or a semi compatible interval as fallback.\n * @param root the root DomQuery element to start from\n * @param condition the condition lambda to be fulfilled\n * @param options options for the search\n */\nfunction waitUntilDom(root: DomQuery, condition: (element: DomQuery) => boolean, options: WAIT_OPTS = {\n    attributes: true,\n    childList: true,\n    subtree: true,\n    timeout: 500,\n    interval: 100\n}): Promise<DomQuery> {\n    return new Promise<DomQuery>((success, error) => {\n        let observer: MutationObserver = null;\n        const MUT_ERROR = new Error(\"Mutation observer timeout\");\n\n        //we do the same but for now ignore the options on the dom query\n        //we cannot use absent here, because the condition might search for an absent element\n        function findElement(root: DomQuery, condition: (element: DomQuery) => boolean): DomQuery | null {\n            let found = null;\n            if (!!condition(root)) {\n                return root;\n            }\n            if (options.childList) {\n                found = (condition(root)) ? root : root.childNodes.filter(item => condition(item)).first().value.value;\n            } else if (options.subtree) {\n                found = (condition(root)) ? root : root.querySelectorAll(\" * \").filter(item => condition(item)).first().value.value;\n            } else {\n                found = (condition(root)) ? root : null;\n            }\n            return found;\n        }\n\n        let foundElement = root;\n        if (!!(foundElement = findElement(foundElement, condition))) {\n            success(new DomQuery(foundElement));\n            return;\n        }\n\n        if ('undefined' != typeof MutationObserver) {\n            const mutTimeout = setTimeout(() => {\n                observer.disconnect();\n                return error(MUT_ERROR);\n            }, options.timeout);\n\n            const callback: MutationCallback = (mutationList: MutationRecord[]) => {\n                const found = new DomQuery(mutationList.map((mut) => mut.target)).filter(item => condition(item)).first();\n                if (found.isPresent()) {\n                    clearTimeout(mutTimeout);\n                    observer.disconnect();\n                    success(new DomQuery(found || root));\n                }\n            }\n            observer = new MutationObserver(callback);\n\n            // browsers might ignore it, but we cannot break the api in the case\n            // hence no timeout is passed\n            let observableOpts = {...options};\n            delete observableOpts.timeout;\n            root.eachElem(item => {\n                observer.observe(item, observableOpts)\n            })\n        } else { //fallback for legacy browsers without mutation observer\n\n            let interval = setInterval(() => {\n                let found = findElement(root, condition);\n                if (!!found) {\n                    if (timeout) {\n                        clearTimeout(timeout);\n                        clearInterval(interval);\n                        interval = null;\n                    }\n                    success(new DomQuery(found || root));\n                }\n            }, options.interval);\n            let timeout = setTimeout(() => {\n                if (interval) {\n                    clearInterval(interval);\n                    error(MUT_ERROR);\n                }\n            }, options.timeout)\n\n        }\n    });\n}\n\nexport class ElementAttribute extends ValueEmbedder<string> {\n\n    constructor(private element: DomQuery, private name: string, private defaultVal: string = null) {\n        super(element, name);\n    }\n\n    get value(): string {\n        let val: Element[] = this.element.get(0).orElse(...[]).values;\n        if (!val.length) {\n            return this.defaultVal;\n        }\n        return val[0].getAttribute(this.name);\n    }\n\n    set value(value: string) {\n        let val: Element[] = this.element.get(0).orElse(...[]).values;\n        for (let cnt = 0; cnt < val.length; cnt++) {\n            val[cnt].setAttribute(this.name, value);\n        }\n        val[0].setAttribute(this.name, value);\n    }\n\n    protected getClass(): any {\n        return ElementAttribute;\n    }\n\n    static fromNullable<ElementAttribute, T>(value?: any, valueKey: string = \"value\"): ElementAttribute {\n        return <any>new ElementAttribute(value, valueKey);\n    }\n\n}\n\nexport class Style extends ValueEmbedder<string> {\n\n    constructor(private element: DomQuery, private name: string, private defaultVal: string = null) {\n        super(element, name);\n    }\n\n    get value(): string {\n        let val: Element[] = this.element.values;\n        if (!val.length) {\n            return this.defaultVal;\n        }\n        return (val[0] as HTMLElement).style[this.name];\n    }\n\n    set value(value: string) {\n        let val: HTMLElement[] = this.element.values as HTMLElement[];\n        for (let cnt = 0; cnt < val.length; cnt++) {\n            val[cnt].style[this.name] = value;\n        }\n    }\n\n    protected getClass(): any {\n        return ElementAttribute;\n    }\n\n    static fromNullable<ElementAttribute, T>(value?: any, valueKey: string = \"value\"): ElementAttribute {\n        return <any>new ElementAttribute(value, valueKey);\n    }\n\n}\n\n/**\n * small helper for the specialized jsf case\n * @constructor\n */\nconst DEFAULT_WHITELIST = () => {\n    return true;\n};\n\ninterface IDomQuery {\n    /**\n     * reference to the systems global object\n     * (globalThis, window, global, depending on the environment)\n     */\n    readonly global: any;\n    /**\n     * reads the first element if it exists and returns an optional\n     */\n    readonly value: Optional<Element>;\n    /**\n     * All elements as array\n     */\n    readonly values: Element[];\n    /**\n     * returns the id as settable value (See also ValueEmbedder)\n     */\n    readonly id: ValueEmbedder<string>;\n    /**\n     * returns the length of embedded nodes (top level)\n     */\n    readonly length: number;\n    /**\n     * the tag name of the first element\n     */\n    readonly tagName: Optional<string>;\n    /**\n     * the node name of the first element\n     */\n    readonly nodeName: Optional<string>;\n    /**\n     * the type of the first element\n     */\n    readonly type: Optional<string>;\n    /**\n     * The name as changeable value\n     */\n    readonly name: ValueEmbedder<string>;\n    /**\n     * The the value in case of inputs as changeable value\n     */\n    readonly inputValue: ValueEmbedder<string | boolean>;\n\n    /**\n     * accumulated top element offsetWidth\n     */\n    readonly offsetWidth: number;\n    /**\n     * accumulated top element offsetHeight\n     */\n    readonly offsetHeight: number;\n    /**\n     * accumulated top element offsetLeft\n     */\n    readonly offsetLeft: number;\n    /**\n     * accumulated top element offsetTop\n     */\n    readonly offsetTop: number;\n\n\n    /**\n     * abbreviation for inputValue.value to make\n     * the code terser\n     */\n    val: string | boolean;\n\n    /**\n     * the underlying form elements as domquery object\n     */\n    readonly elements: DomQuery;\n    /**\n     * settable flag for disabled\n     */\n    disabled: boolean;\n    /**\n     * The child nodes of this node collection as readonly attribute\n     */\n    readonly childNodes: DomQuery;\n    /**\n     * an early stream representation for this DomQuery\n     */\n    readonly stream: Stream<DomQuery>;\n    /**\n     * lazy stream representation for this DomQuery\n     */\n    readonly lazyStream: LazyStream<DomQuery>;\n    /**\n     * transform this node collection to an array\n     */\n    readonly asArray: Array<DomQuery>;\n\n    /**\n     * inner html property\n     * setter and getter which works directly on strings\n     */\n    innerHTML: string;\n\n    /**\n     * same as innerHTML\n     * will be removed once\n     * my code is transitioned\n     * @deprecated do not use anymore, user innerHTML instead\n     */\n    innerHtml: string;\n\n    /**\n     * returns true if the elements have the tag *tagName* as tag embedded (highest level)\n     * @param tagName\n     */\n    isTag(tagName: string): boolean;\n\n    /**\n     * returns the nth element as domquery\n     * from the internal elements\n     * note if you try to reach a non existing element position\n     * you will get back an absent entry\n     *\n     * @param index the nth index\n     */\n    get(index: number): DomQuery;\n\n    /**\n     * returns the nth element as optional of an Element object\n     * @param index the number from the index\n     * @param defaults the default value if the index is overrun default Optional.absent\n     */\n    getAsElem(index: number, defaults: Optional<any>): Optional<Element>;\n\n    /**\n     * returns the value array< of all elements\n     */\n    allElems(): Array<Element>;\n\n    /**\n     * absent no values reached?\n     */\n    isAbsent(): boolean;\n\n    /**\n     * should make the code clearer\n     * note if you pass a function\n     * this refers to the active dopmquery object\n     */\n    isPresent(presentRunnable ?: (elem ?: DomQuery) => void): boolean;\n\n    /**\n     * should make the code clearer\n     * note if you pass a function\n     * this refers to the active dopmquery object\n     *\n     *\n     * @param presentRunnable\n     */\n    ifPresentLazy(presentRunnable: (elem ?: DomQuery) => void): DomQuery;\n\n    /**\n     * remove all affected nodes from this query object from the dom tree\n     */\n    delete(): void;\n\n    /**\n     * query selector all on the existing dom query object\n     *\n     * @param selector the standard selector\n     * @return a DomQuery with the results\n     */\n    querySelectorAll(selector): DomQuery;\n\n    /**\n     * core byId method\n     * @param id the id to search for\n     * @param includeRoot also match the root element?\n     */\n    byId(id: string, includeRoot?: boolean): DomQuery;\n\n    /**\n     * same as byId just for the tag name\n     * @param tagName\n     * @param includeRoot\n     */\n    byTagName(tagName: string, includeRoot ?: boolean): DomQuery;\n\n    /**\n     * attr accessor, usage myQuery.attr(\"class\").value = \"bla\"\n     * or let value myQuery.attr(\"class\").value\n     * @param attr the attribute to set\n     * @param defaultValue the default value in case nothing is presented (defaults to null)\n     */\n    attr(attr: string, defaultValue: string): ElementAttribute;\n\n    /**\n     * style accessor\n     * @param defaultValue the default value in case nothing is presented (defaults to null)\n     * @param cssProperty\n     */\n    style(cssProperty: string, defaultValue: string): Style;\n\n    /**\n     * hasclass, checks for an existing class in the class attributes\n     *\n     * @param clazz the class to search for\n     */\n    hasClass(clazz: string): boolean;\n\n    /**\n     * appends a class string if not already in the element(s)\n     *\n     * @param clazz the style class to append\n     */\n    addClass(clazz: string): DomQuery;\n\n    /**\n     * remove the style class if in the class definitions\n     *\n     * @param clazz\n     */\n    removeClass(clazz: string): DomQuery;\n\n    /**\n     * checks whether we have a multipart element in our children\n     */\n    isMultipartCandidate(): boolean;\n\n    /**\n     * innerHtml equivalent\n     * equivalent to jQueries html\n     * as setter the html is set and the\n     * DomQuery is given back\n     * as getter the html string is returned\n     *\n     * @param inval\n     */\n    html(inval?: string): DomQuery | Optional<string>;\n\n    /**\n     * dispatch event on all children\n     * just a delegated dispatchevent from the standard\n     * dom working on all queried elements in the monad level\n     *\n     * @param evt the event to be dispatched\n     */\n    dispatchEvent(evt: Event): DomQuery;\n\n    /**\n     * easy node traversal, you can pass\n     * a set of node selectors which are joined as direct childs\n     *\n     * not the rootnodes are not in the getIf, those are always the child nodes\n     *\n     * @param nodeSelector\n     */\n    getIf(...nodeSelector: Array<string>): DomQuery;\n\n    /**\n     * iterate over each element and perform something on the element\n     * (Dom element is passed instead of DomQuery)\n     * @param func\n     */\n    eachElem(func: (item: Element, cnt?: number) => any): DomQuery;\n\n    /**\n     * perform an operation on the first element\n     * returns a DomQuery on the first element only\n     * @param func\n     */\n    firstElem(func: (item: Element, cnt?: number) => any): DomQuery;\n\n    /**\n     * perform an operation on the first element\n     * returns a DomQuery on the first element only\n     * @param func\n     */\n    lastElem(func: (item: Element, cnt?: number) => any): DomQuery;\n\n    /**\n     * same as eachElem, but a DomQuery object is passed down\n     *\n     * @param func\n     */\n    each(func: (item: DomQuery, cnt?: number) => any): DomQuery;\n\n    /**\n     * returns a new dom query containing only the first element max\n     *\n     * @param func a an optional callback function to perform an operation on the first element\n     */\n    first(func: (item: DomQuery, cnt?: number) => any): DomQuery;\n\n\n    /**\n     * returns a new dom query containing only the first element max\n     *\n     * @param func a an optional callback function to perform an operation on the first element\n     */\n    last(func: (item: DomQuery, cnt?: number) => any): DomQuery;\n\n    /**\n     * filter function which filters a subset\n     *\n     * @param func\n     */\n    filter(func: (item: DomQuery) => boolean): DomQuery;\n\n    /**\n     * global eval head appendix method\n     * no other methods are supported anymore\n     * @param code the code to be evaled\n     * @param  nonce optional  nonce key for higher security\n     */\n    globalEval(code: string, nonce ?: string): DomQuery;\n\n    /**\n     * Runs an eval and keeps the evaled code in the head\n     * This is a corner condition, where we want to update the head with custom\n     * code and leave the code in (instead of deleting ig)\n     *\n     * @param code the code to be evaled\n     * @param  nonce optional  nonce key for higher security\n     */\n    globalEvalSticky(code: string, nonce ?: string): DomQuery;\n\n    /**\n     * detaches a set of nodes from their parent elements\n     * in a browser independend manner\n     * @return {DomQuery} DomQuery of nodes with the detached dom nodes\n     */\n    detach(): DomQuery;\n\n    /**\n     * appends the current set of elements\n     * to the element or first element passed via elem\n     * @param elem\n     */\n    appendTo(elem: DomQuery | string): DomQuery;\n\n    /**\n     * appends the passed elements to our existing queries\n     * note, double appends can happen if you are not careful\n     *\n     * @param elem to append\n     */\n    append(elem: DomQuery): DomQuery;\n\n    /**\n     * appends the passed elements to our existing queries\n     * note, double appends can happen if you are not careful\n     *\n     * @param elem to append\n     */\n    prepend(elem: DomQuery): DomQuery;\n\n    /**\n     * prepend eqivalent to appendTo\n     *\n     * @param elem the element to prepend to\n     */\n    prependTo(elem: DomQuery): DomQuery;\n\n    /**\n     * loads and evals a script from a source uri\n     *\n     * @param src the source to be loaded and evaled\n     * @param defer in miliseconds execution default (0 == no defer)\n     * @param charSet\n     */\n    loadScriptEval(src: string, defer: number, charSet: string): void;\n\n    /**\n     * insert toInsert after the current element\n     *\n     * @param toInsert an array of DomQuery objects\n     */\n    insertAfter(...toInsert: Array<DomQuery>): DomQuery;\n\n    /**\n     * inserts the elements before the current element\n     *\n     * @param toInsert\n     */\n    insertBefore(...toInsert: Array<DomQuery>): DomQuery;\n\n    /**\n     * in case the domquery is pointing to nothing the else value is taken into consideration\n     * als alternative\n     *\n     * @param elseValue the else value\n     */\n    orElse(...elseValue: any): DomQuery;\n\n    /**\n     * the same with lazy evaluation for cases where getting the else value\n     * is a heavy operation\n     *\n     * @param func the else provider function\n     */\n    orElseLazy(func: () => any): DomQuery;\n\n    /**\n     * all parents with TagName\n     * @param tagName\n     */\n    parents(tagName: string): DomQuery;\n\n    /**\n     * copy all attributes of sourceItem to this DomQuery items\n     *\n     * @param sourceItem the source item to copy over (can be another domquery or a parsed XML Query item)\n     */\n    copyAttrs(sourceItem: DomQuery | XMLQuery): DomQuery;\n\n    /**\n     * outerhtml convenience method\n     * browsers only support innerHTML but\n     * for instance for your jsf.js we have a full\n     * replace pattern which needs outerHTML processing\n     *\n     * @param markup\n     * @param runEmbeddedScripts\n     * @param runEmbeddedCss\n     */\n    outerHTML(markup: string, runEmbeddedScripts ?: boolean, runEmbeddedCss ?: boolean): DomQuery;\n\n    /**\n     * Run through the given nodes in the DomQuery execute the inline scripts\n     * @param whilteListed: optional whitelist function which can filter out script tags which are not processed\n     * defaults to the standard jsf.js exclusion (we use this code for myfaces)\n     */\n    runScripts(sticky?: boolean, whilteListed?: (val: string) => boolean): DomQuery;\n\n    /**\n     * runs the embedded css\n     */\n    runCss(): DomQuery;\n\n    /**\n     * fires a click event on the underlying dom elements\n     */\n    click(): DomQuery;\n\n    /**\n     * adds an event listener\n     *\n     * @param type\n     * @param listener\n     * @param options\n     */\n    addEventListener(type: string, listener: (evt: Event) => void, options?: boolean | EventListenerOptions): DomQuery;\n\n    /**\n     * removes an event listener\n     *\n     * @param type\n     * @param listener\n     * @param options\n     */\n    removeEventListener(type: string, listener: (evt: Event) => void, options?: boolean | EventListenerOptions): DomQuery;\n\n    /**\n     * fires an event\n     */\n    fireEvent(eventName: string): void;\n\n    /*\n     * pushes  in optionally a new textContent, and/or returns the current text content\n     */\n    textContent(joinstr?: string): string;\n\n    /*\n     * pushes  in optionally a new innerText, and/or returns the current innerText\n     */\n    innerText(joinstr?: string): string;\n\n    /**\n     * encodes all input elements properly into respective\n     * config entries, this can be used\n     * for legacy systems, for newer usecases, use the\n     * HTML5 Form class which all newer browsers provide\n     *\n     * @param toMerge optional config which can be merged in\n     * @return a copy pf\n     */\n    encodeFormElement(toMerge): Config;\n\n    /**\n     * fetches the subnodes from ... to..\n     * @param from\n     * @param to\n     */\n    subNodes(from: number, to?: number): DomQuery;\n\n\n    /**\n     * attach shadow elements\n     * 1:1 mapping from attach shadow\n     *\n     * @param modeParams\n     */\n    attachShadow(modeParams: { [key: string]: string }): DomQuery\n\n\n    /**\n     * wait until a condition on the dom is reached\n     *\n     * @return a promise on the affected elements where the condition\n     * @throws an error in case of a timeout\n     */\n    waitUntilDom(condition: (element: DomQuery) => boolean, options: WAIT_OPTS): Promise<DomQuery>;\n\n    //observable: Observable<DomQuery>;\n\n    //observableElem: Observable<Element>;\n}\n\n/**\n * Monadic DomNode representation, ala jquery\n * This is a thin wrapper over querySelectorAll\n * to get slim monadic support\n * to reduce implementation code on the users side.\n * This is vital for frameworks which want to rely on\n * plain dom but still do not want to lose\n * the reduced code footprint of querying dom trees and traversing\n * by using functional patterns.\n *\n * Also a few convenience methods are added to reduce\n * the code footprint of standard dom processing\n * operations like eval\n *\n * TODO add jquery fallback support, since it is supported\n * in most older systems\n * Note parts of this code still stem from the Dom.js I have written 10 years\n * ago, those parts look a little bit ancient and will be replaced over time.\n *\n */\nexport class DomQuery implements IDomQuery, IStreamDataSource<DomQuery>, Iterable<DomQuery> {\n\n    static absent = new DomQuery();\n\n    /**\n     * reference to the environmental global object\n     */\n    static global = _global$;\n\n    private rootNode: Array<Element> = [];\n\n    pos = -1;\n\n    constructor(...rootNode: Array<Element | ShadowRoot | DomQuery | Document | Array<any> | string>) {\n\n        if (Optional.fromNullable(rootNode).isAbsent() || !rootNode.length) {\n            return;\n        } else {\n            //we need to flatten out the arrays\n\n            for (let cnt = 0; cnt < rootNode.length; cnt++) {\n                if (!rootNode[cnt]) {\n                    //we skip possible null entries which can happen in\n                    //certain corner conditions due to the constructor re-wrapping single elements into arrays.\n                } else if (isString(rootNode[cnt])) {\n                    let foundElement = DomQuery.querySelectorAll(<string>rootNode[cnt]);\n                    if (!foundElement.isAbsent()) {\n                        rootNode.push(...foundElement.values)\n                    }\n                } else if (rootNode[cnt] instanceof DomQuery) {\n                    this.rootNode.push(...(<any>rootNode[cnt]).values);\n                } else {\n                    this.rootNode.push(<any>rootNode[cnt]);\n                }\n            }\n        }\n    }\n\n\n    /**\n     * returns the first element\n     */\n    get value(): Optional<Element> {\n        return this.getAsElem(0);\n    }\n\n    get values(): Element[] {\n        return this.allElems();\n    }\n\n    get global(): any {\n        return _global$;\n    }\n\n    /**\n     * returns the id of the first element\n     */\n    get id(): ValueEmbedder<string> {\n        return new ElementAttribute(this.get(0), \"id\");\n    }\n\n    /**\n     * length of the entire query set\n     */\n    get length(): number {\n        return this.rootNode.length\n    }\n\n    /**\n     * convenience method for tagName\n     */\n    get tagName(): Optional<string> {\n        return <Optional<string>>this.getAsElem(0).getIf(\"tagName\");\n    }\n\n    /**\n     * convenience method for nodeName\n     */\n    get nodeName(): Optional<string> {\n        return <Optional<string>>this.getAsElem(0).getIf(\"nodeName\");\n    }\n\n    isTag(tagName: string): boolean {\n        return !this.isAbsent()\n            && (this.nodeName.orElse(\"__none___\")\n                    .value.toLowerCase() == tagName.toLowerCase()\n                || this.tagName.orElse(\"__none___\")\n                    .value.toLowerCase() == tagName.toLowerCase()\n            )\n    }\n\n    /**\n     * convenience property for type\n     *\n     * returns null in case of no type existing otherwise\n     * the type of the first element\n     */\n    get type(): Optional<string> {\n        return this.getAsElem(0).getIf(\"type\");\n    }\n\n    /**\n     * convenience property for name\n     *\n     * returns null in case of no type existing otherwise\n     * the name of the first element\n     */\n    get name(): ValueEmbedder<string> {\n        return new ValueEmbedder(this.getAsElem(0).value, \"name\");\n    }\n\n    /**\n     * convenience property for value\n     *\n     * returns null in case of no type existing otherwise\n     * the value of the first element\n     */\n    get inputValue(): ValueEmbedder<string | boolean> {\n        if (this.getAsElem(0).getIf(\"value\").isPresent()) {\n            return new ValueEmbedder<string>(this.getAsElem(0).value);\n        } else {\n            return <any>ValueEmbedder.absent;\n        }\n    }\n\n    get val(): string | boolean {\n        return this.inputValue.value;\n    }\n\n    set val(value: string | boolean) {\n        this.inputValue.value = value;\n    }\n\n    get checked(): boolean {\n        return Stream.of(...this.values).allMatch(el => !!(<any>el).checked);\n    }\n\n    set checked(newChecked: boolean) {\n        this.eachElem(el => (<any>el).checked = newChecked);\n    }\n\n    get elements(): DomQuery {\n        //a simple querySelectorAll should suffice\n        return this.querySelectorAll(\"input, checkbox, select, textarea, fieldset\");\n    }\n\n    get deepElements(): DomQuery {\n        let elemStr = \"input, select, textarea, checkbox, fieldset\";\n        return this.querySelectorAllDeep(elemStr);\n    }\n\n    /**\n     * a deep search which treats the single isolated shadow doms\n     * separately and runs the query on earch shadow dom\n     * @param queryStr\n     */\n    querySelectorAllDeep(queryStr: string): DomQuery {\n        let found: Array<DomQuery> = [];\n        let queryRes = this.querySelectorAll(queryStr);\n        if (queryRes.length) {\n            found.push(queryRes);\n        }\n        let shadowRoots = this.querySelectorAll(\"*\").shadowRoot;\n        if (shadowRoots.length) {\n            let shadowRes = shadowRoots.querySelectorAllDeep(queryStr);\n            if (shadowRes.length) {\n                found.push(shadowRes);\n            }\n        }\n        return new DomQuery(...found);\n    }\n\n\n    /**\n     * todo align this api with the rest of the apis\n     */\n    get disabled(): boolean {\n        return this.attr(\"disabled\").isPresent();\n    }\n\n    set disabled(disabled: boolean) {\n        // this.attr(\"disabled\").value = disabled + \"\";\n        if (!disabled) {\n            this.removeAttribute(\"disabled\");\n        } else {\n            this.attr(\"disabled\").value = \"disabled\";\n        }\n\n    }\n\n    removeAttribute(name: string) {\n        this.eachElem(item => item.removeAttribute(name));\n    }\n\n    get childNodes(): DomQuery {\n        let childNodeArr: Array<Element> = [];\n        this.eachElem((item: Element) => {\n            childNodeArr = childNodeArr.concat(objToArray(item.childNodes));\n        });\n        return new DomQuery(...childNodeArr);\n    }\n\n    /**\n     * binding into stream\n     */\n    get stream(): Stream<DomQuery> {\n        return new Stream<DomQuery>(...this.asArray);\n    }\n\n    /**\n     * fetches a lazy stream representation\n     * lazy should be applied if you have some filters etc\n     * in between, this can reduce the number of post filter operations\n     * and ram usage\n     * significantly because the operations are done lazily and stop\n     * once they hit a dead end.\n     */\n    get lazyStream(): LazyStream<DomQuery> {\n        return LazyStream.of(...this.asArray);\n    }\n\n    get asArray(): Array<DomQuery> {\n        //filter not supported by IE11\n        return [].concat(LazyStream.of(...this.rootNode).filter(item => {\n            return item != null\n        })\n            .map(item => {\n                return DomQuery.byId(item)\n            }).collect(new ArrayCollector()));\n    }\n\n    get offsetWidth(): number {\n        return LazyStream.of(...this.rootNode)\n            .filter(item => item != null)\n            .map(elem => (elem as HTMLElement).offsetWidth)\n            .reduce((accumulate, incoming) => accumulate + incoming, 0).value;\n    }\n\n    get offsetHeight(): number {\n        return LazyStream.of(...this.rootNode)\n            .filter(item => item != null)\n            .map(elem => (elem as HTMLElement).offsetHeight)\n            .reduce((accumulate, incoming) => accumulate + incoming, 0).value;\n    }\n\n    get offsetLeft(): number {\n        return LazyStream.of(...this.rootNode)\n            .filter(item => item != null)\n            .map(elem => (elem as HTMLElement).offsetLeft)\n            .reduce((accumulate, incoming) => accumulate + incoming, 0).value;\n    }\n\n    get offsetTop(): number {\n        return LazyStream.of(...this.rootNode)\n            .filter(item => item != null)\n            .map(elem => (elem as HTMLElement).offsetTop)\n            .reduce((accumulate, incoming) => accumulate + incoming, 0).value;\n    }\n\n    get asNodeArray(): Array<DomQuery> {\n        return [].concat(Stream.of(this.rootNode).filter(item => item != null).collect(new ArrayCollector()));\n    }\n\n\n    static querySelectorAllDeep(selector: string) {\n        return new DomQuery(document).querySelectorAllDeep(selector);\n    }\n\n    /**\n     * easy query selector all producer\n     *\n     * @param selector the selector\n     * @returns a results dom query object\n     */\n    static querySelectorAll(selector: string): DomQuery {\n        if (selector.indexOf(\"/shadow/\") != -1) {\n            return new DomQuery(document)._querySelectorAllDeep(selector);\n        } else {\n            return new DomQuery(document)._querySelectorAll(selector);\n        }\n    }\n\n    /**\n     * byId producer\n     *\n     * @param selector id\n     * @param deep true if you want to go into shadow areas\n     * @return a DomQuery containing the found elements\n     */\n    static byId(selector: string | DomQuery | Element, deep = false): DomQuery {\n        if (isString(selector)) {\n            return (!deep) ? new DomQuery(document).byId(<string>selector) : new DomQuery(document).byIdDeep(<string>selector);\n        } else {\n            return new DomQuery(<any>selector);\n        }\n    }\n\n    /**\n     * byTagName producer\n     *\n     * @param selector name\n     * @return a DomQuery containing the found elements\n     */\n    static byTagName(selector: string | DomQuery | Element): DomQuery {\n        if (isString(selector)) {\n            return new DomQuery(document).byTagName(<string>selector);\n        } else {\n            return new DomQuery(<any>selector);\n        }\n    }\n\n    static globalEval(code: string, nonce?: string): DomQuery {\n        return new DomQuery(document).globalEval(code, nonce);\n    }\n\n    static globalEvalSticky(code: string, nonce?: string): DomQuery {\n        return new DomQuery(document).globalEvalSticky(code, nonce);\n    }\n\n    /**\n     * builds the ie nodes properly in a placeholder\n     * and bypasses a non script insert bug that way\n     * @param markup the marku code\n     */\n    static fromMarkup(markup: string): DomQuery {\n\n        //https://developer.mozilla.org/de/docs/Web/API/DOMParser license creative commons\n        const doc = document.implementation.createHTMLDocument(\"\");\n        markup = trim(markup);\n        let lowerMarkup = markup.toLowerCase();\n        if (lowerMarkup.indexOf('<!doctype') != -1 ||\n            lowerMarkup.indexOf('<html') != -1 ||\n            lowerMarkup.indexOf('<head') != -1 || //TODO proper regexps here to avoid embedded tags with same element names to be triggered\n            lowerMarkup.indexOf('<body') != -1) {\n            doc.documentElement.innerHTML = markup;\n            return new DomQuery(doc.documentElement);\n        } else {\n            let startsWithTag = function (str: string, tagName: string) {\n                let tag1 = [\"<\", tagName, \">\"].join(\"\");\n                let tag2 = [\"<\", tagName, \" \"].join(\"\");\n                return (str.indexOf(tag1) == 0) || (str.indexOf(tag2) == 0);\n            };\n\n            let dummyPlaceHolder = new DomQuery(document.createElement(\"div\"));\n\n            //table needs special treatment due to the browsers auto creation\n            if (startsWithTag(lowerMarkup, \"thead\") || startsWithTag(lowerMarkup, \"tbody\")) {\n                dummyPlaceHolder.html(`<table>${markup}</table>`);\n                return dummyPlaceHolder.querySelectorAll(\"table\").get(0).childNodes.detach();\n            } else if (startsWithTag(lowerMarkup, \"tfoot\")) {\n                dummyPlaceHolder.html(`<table><thead></thead><tbody><tbody${markup}</table>`);\n                return dummyPlaceHolder.querySelectorAll(\"table\").get(2).childNodes.detach();\n            } else if (startsWithTag(lowerMarkup, \"tr\")) {\n                dummyPlaceHolder.html(`<table><tbody>${markup}</tbody></table>`);\n                return dummyPlaceHolder.querySelectorAll(\"tbody\").get(0).childNodes.detach();\n            } else if (startsWithTag(lowerMarkup, \"td\")) {\n                dummyPlaceHolder.html(`<table><tbody><tr>${markup}</tr></tbody></table>`);\n                return dummyPlaceHolder.querySelectorAll(\"tr\").get(0).childNodes.detach();\n            }\n\n            dummyPlaceHolder.html(markup);\n            return dummyPlaceHolder.childNodes.detach();\n        }\n\n    }\n\n    /**\n     * returns the nth element as domquery\n     * from the internal elements\n     * note if you try to reach a non existing element position\n     * you will get back an absent entry\n     *\n     * @param index the nth index\n     */\n    get(index: number): DomQuery {\n        return (index < this.rootNode.length) ? new DomQuery(this.rootNode[index]) : DomQuery.absent;\n    }\n\n\n    /**\n     * returns the nth element as optional of an Element object\n     * @param index the number from the index\n     * @param defaults the default value if the index is overrun default Optional.absent\n     */\n    getAsElem(index: number, defaults: Optional<any> = Optional.absent): Optional<Element> {\n        return (index < this.rootNode.length) ? Optional.fromNullable(this.rootNode[index]) : defaults;\n    }\n\n    /**\n     * returns the files from a given elmement\n     * @param index\n     */\n    filesFromElem(index: number): Array<any> {\n        return (index < this.rootNode.length) ? (<any>this.rootNode[index])?.files ? (<any>this.rootNode[index]).files : [] : [];\n    }\n\n    /**\n     * returns the value array< of all elements\n     */\n    allElems(): Array<Element> {\n        return this.rootNode;\n    }\n\n    /**\n     * absent no values reached?\n     */\n    isAbsent(): boolean {\n        return this.length == 0;\n    }\n\n    /**\n     * should make the code clearer\n     * note if you pass a function\n     * this refers to the active dopmquery object\n     */\n    isPresent(presentRunnable ?: (elem ?: DomQuery) => void): boolean {\n        let absent = this.isAbsent();\n        if (!absent && presentRunnable) {\n            presentRunnable.call(this, this)\n        }\n        return !absent;\n    }\n\n    /**\n     * should make the code clearer\n     * note if you pass a function\n     * this refers to the active dopmquery object\n     *\n     *\n     * @param presentRunnable\n     */\n    ifPresentLazy(presentRunnable: (elem ?: DomQuery) => void = function () {\n    }): DomQuery {\n        this.isPresent.call(this, presentRunnable);\n        return this;\n    }\n\n    /**\n     * remove all affected nodes from this query object from the dom tree\n     */\n    delete() {\n        this.eachElem((node: Element) => {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        });\n    }\n\n    querySelectorAll(selector): DomQuery {\n        //We could merge both methods, but for now this is more readable\n        if (selector.indexOf(\"/shadow/\") != -1) {\n            return this._querySelectorAllDeep(selector);\n        } else {\n            return this._querySelectorAll(selector);\n        }\n    }\n\n    /**\n     * query selector all on the existing dom queryX object\n     *\n     * @param selector the standard selector\n     * @return a DomQuery with the results\n     */\n    private _querySelectorAll(selector): DomQuery {\n        if (!this?.rootNode?.length) {\n            return this;\n        }\n        let nodes = [];\n        for (let cnt = 0; cnt < this.rootNode.length; cnt++) {\n            if (!this.rootNode[cnt]?.querySelectorAll) {\n                continue;\n            }\n            let res = this.rootNode[cnt].querySelectorAll(selector);\n            nodes = nodes.concat(objToArray(res));\n        }\n\n        return new DomQuery(...nodes);\n    }\n\n\n    /*deep with a selector and a peudo /shadow/ marker to break into the next level*/\n    private _querySelectorAllDeep(selector): DomQuery {\n        if (!this?.rootNode?.length) {\n            return this;\n        }\n\n        let foundNodes: DomQuery = new DomQuery(...this.rootNode);\n        let selectors = selector.split(/\\/shadow\\//);\n\n        for (let cnt2 = 0; cnt2 < selectors.length; cnt2++) {\n            if (selectors[cnt2] == \"\") {\n                continue;\n            }\n            let levelSelector = selectors[cnt2];\n            foundNodes = foundNodes.querySelectorAll(levelSelector);\n            if (cnt2 < selectors.length - 1) {\n                foundNodes = foundNodes.shadowRoot;\n            }\n        }\n\n        return foundNodes;\n    }\n\n    /**\n     * core byId method\n     * @param id the id to search for\n     * @param includeRoot also match the root element?\n     */\n    byId(id: string, includeRoot?: boolean): DomQuery {\n        let res: Array<DomQuery> = [];\n        if (includeRoot) {\n            res = res.concat(\n                LazyStream.of(...(this?.rootNode || []))\n                    .filter(item => id == item.id)\n                    .map(item => new DomQuery(item))\n                    .collect(new ArrayCollector())\n            );\n        }\n\n        //for some strange kind of reason the # selector fails\n        //on hidden elements we use the attributes match selector\n        //that works\n        res = res.concat(this.querySelectorAll(`[id=\"${id}\"]`));\n        return new DomQuery(...res);\n    }\n\n\n    byIdDeep(id: string, includeRoot?: boolean): DomQuery {\n        let res: Array<DomQuery> = [];\n        if (includeRoot) {\n            res = res.concat(\n                LazyStream.of(...(this?.rootNode || []))\n                    .filter(item => id == item.id)\n                    .map(item => new DomQuery(item))\n                    .collect(new ArrayCollector())\n            );\n        }\n\n        let subItems = this.querySelectorAllDeep(`[id=\"${id}\"]`);\n        if (subItems.length) {\n            res.push(subItems);\n        }\n\n        return new DomQuery(...res);\n    }\n\n    /**\n     * same as byId just for the tag name\n     * @param tagName the tagname to search for\n     * @param includeRoot shall the root element be part of this search\n     * @param deep do we also want to go into shadow dom areas\n     */\n    byTagName(tagName: string, includeRoot ?: boolean, deep ?: boolean): DomQuery {\n        let res: Array<Element | DomQuery> = [];\n        if (includeRoot) {\n            res = <any>LazyStream.of(...(this?.rootNode ?? []))\n                .filter(element => element?.tagName == tagName)\n                .reduce<Array<Element | DomQuery>>((reduction: any, item: Element) => reduction.concat([item]), res)\n                .orElse(res).value;\n        }\n\n        (deep) ? res.push(this.querySelectorAllDeep(tagName)) : res.push(this.querySelectorAll(tagName));\n        return new DomQuery(...res);\n    }\n\n    /**\n     * attr accessor, usage myQuery.attr(\"class\").value = \"bla\"\n     * or let value myQuery.attr(\"class\").value\n     * @param attr the attribute to set\n     * @param defaultValue the default value in case nothing is presented (defaults to null)\n     */\n    attr(attr: string, defaultValue: string = null): ElementAttribute {\n        return new ElementAttribute(this, attr, defaultValue);\n    }\n\n    style(cssProperty: string, defaultValue: string = null): Style {\n        return new Style(this, cssProperty, defaultValue);\n    }\n\n\n    /**\n     * hasclass, checks for an existing class in the class attributes\n     *\n     * @param clazz the class to search for\n     */\n    hasClass(clazz: string) {\n        let hasIt = false;\n        this.eachElem(node => {\n            hasIt = node.classList.contains(clazz);\n            if (hasIt) {\n                return false;\n            }\n        });\n        return hasIt;\n    }\n\n    /**\n     * appends a class string if not already in the element(s)\n     *\n     * @param clazz the style class to append\n     */\n    addClass(clazz: string): DomQuery {\n        this.eachElem(item => item.classList.add(clazz))\n        return this;\n    }\n\n    /**\n     * remove the style class if in the class definitions\n     *\n     * @param clazz\n     */\n    removeClass(clazz: string): DomQuery {\n        this.eachElem(item => item.classList.remove(clazz));\n        return this;\n    }\n\n    /**\n     * checks whether we have a multipart element in our children\n     * or are one\n     */\n    isMultipartCandidate(deep = false): boolean {\n        const FILE_INPUT = \"input[type='file']\";\n        return this.matchesSelector(FILE_INPUT) ||\n            ((!deep) ? this.querySelectorAll(FILE_INPUT) :\n                this.querySelectorAllDeep(FILE_INPUT)).first().isPresent();\n    }\n\n    /**\n     * innerHtml equivalkent\n     * equivalent to jqueries html\n     * as setter the html is set and the\n     * DomQuery is given back\n     * as getter the html string is returned\n     *\n     * @param inval\n     */\n    html(inval?: string): DomQuery | Optional<string> {\n        if (Optional.fromNullable(inval).isAbsent()) {\n            return this.isPresent() ? Optional.fromNullable(this.innerHTML) : Optional.absent;\n        }\n        this.innerHTML = inval;\n\n        return this;\n    }\n\n    /**\n     * Standard dispatch event method, delegated from node\n     */\n    dispatchEvent(evt: Event): DomQuery {\n        this.eachElem(elem => elem.dispatchEvent(evt));\n        return this;\n    }\n\n    set innerHTML(inVal: string) {\n        this.eachElem(elem => elem.innerHTML = inVal);\n    }\n\n    get innerHTML(): string {\n        let retArr = [];\n        this.eachElem(elem => retArr.push(elem.innerHTML));\n        return retArr.join(\"\");\n    }\n\n    set innerHtml(inval: string) {\n        this.innerHTML = inval;\n    }\n\n    get innerHtml(): string {\n        return this.innerHTML;\n    }\n\n    //source: https://developer.mozilla.org/en-US/docs/Web/API/Element/matches\n    //code snippet license: https://creativecommons.org/licenses/by-sa/2.5/\n    private _mozMatchesSelector(toMatch: Element, selector: string): boolean {\n        let prot: { [key: string]: Function } = (<any>toMatch);\n        let matchesSelector: Function = prot.matches ||\n            prot.matchesSelector ||\n            prot.mozMatchesSelector ||\n            prot.msMatchesSelector ||\n            prot.oMatchesSelector ||\n            prot.webkitMatchesSelector ||\n            function (s: string) {\n                let matches: NodeListOf<HTMLElement> = (document || ownerDocument).querySelectorAll(s),\n                    i = matches.length;\n                while (--i >= 0 && matches.item(i) !== toMatch) {\n                }\n                return i > -1;\n            };\n        return matchesSelector.call(toMatch, selector);\n    }\n\n    /**\n     * filters the current dom query elements\n     * upon a given selector\n     *\n     * @param selector\n     */\n    filterSelector(selector: string): DomQuery {\n        let matched = [];\n\n        this.eachElem(item => {\n            if (this._mozMatchesSelector(item, selector)) {\n                matched.push(item)\n            }\n        });\n        return new DomQuery(...matched);\n    }\n\n    /**\n     * checks whether any item in this domQuery level matches the selector\n     * if there is one element only attached, as root the match is only\n     * performed on this element.\n     * @param selector\n     */\n    matchesSelector(selector: string): boolean {\n        const ret = this.lazyStream\n            .map(item => this._mozMatchesSelector(item.getAsElem(0).value, selector))\n            .filter(match => match)\n            .first();\n        return ret.isPresent();\n    }\n\n    /**\n     * easy node traversal, you can pass\n     * a set of node selectors which are joined as direct childs\n     *\n     * not the rootnodes are not in the getIf, those are always the child nodes\n     *\n     * @param nodeSelector\n     */\n    getIf(...nodeSelector: Array<string>): DomQuery {\n\n        let selectorStage: DomQuery = this.childNodes;\n        for (let cnt = 0; cnt < nodeSelector.length; cnt++) {\n            selectorStage = selectorStage.filterSelector(nodeSelector[cnt]);\n            if (selectorStage.isAbsent()) {\n                return selectorStage;\n            }\n        }\n        return selectorStage;\n    }\n\n    eachElem(func: (item: Element, cnt?: number) => any): DomQuery {\n\n        for (let cnt = 0, len = this.rootNode.length; cnt < len; cnt++) {\n            if (func(this.rootNode[cnt], cnt) === false) {\n                break;\n            }\n        }\n        return this;\n    }\n\n    firstElem(func: (item: Element, cnt?: number) => any = item => item): DomQuery {\n        if (this.rootNode.length > 1) {\n            func(this.rootNode[0], 0);\n        }\n        return this;\n    }\n\n    lastElem(func: (item: Element, cnt?: number) => any = item => item): DomQuery {\n        if (this.rootNode.length > 1) {\n            func(this.rootNode[this.rootNode.length - 1], 0);\n        }\n        return this;\n    }\n\n    each(func: (item: DomQuery, cnt?: number) => any): DomQuery {\n        Stream.of(...this.rootNode)\n            .each((item, cnt) => {\n                //we could use a filter, but for the best performance we dont\n                if (item == null) {\n                    return;\n                }\n                return func(DomQuery.byId(item), cnt);\n            });\n\n        return this;\n    }\n\n    /**\n     * returns a new dom query containing only the first element max\n     *\n     * @param func a an optional callback function to perform an operation on the first element\n     */\n    first(func: (item: DomQuery, cnt?: number) => any = (item) => item): DomQuery {\n        if (this.rootNode.length >= 1) {\n            func(this.get(0), 0);\n            return this.get(0);\n        }\n        return this;\n    }\n\n    /**\n     * returns a new dom query containing only the first element max\n     *\n     * @param func a an optional callback function to perform an operation on the first element\n     */\n    last(func: (item: DomQuery, cnt?: number) => any = (item) => item): DomQuery {\n        if (this.rootNode.length >= 1) {\n            let lastNode = this.get(this.rootNode.length - 1);\n            func(lastNode, 0);\n            return lastNode;\n        }\n        return this;\n    }\n\n    /**\n     * filter function which filters a subset\n     *\n     * @param func\n     */\n    filter(func: (item: DomQuery) => boolean): DomQuery {\n        let reArr: Array<DomQuery> = [];\n        this.each((item: DomQuery) => {\n            func(item) ? reArr.push(item) : null;\n        });\n        return new DomQuery(...<any>reArr);\n    }\n\n    //TODO append prepend\n\n    /**\n     * global eval head appendix method\n     * no other methods are supported anymore\n     * @param code the code to be evaled\n     * @param  nonce optional  nonce key for higher security\n     */\n    globalEval(code: string, nonce ?: string): DomQuery {\n        let head = document.getElementsByTagName(\"head\")[0] || document.documentElement;\n        let script = document.createElement(\"script\");\n        if (nonce) {\n            if ('undefined' != typeof script?.nonce) {\n                script.nonce = nonce;\n            } else {\n                script.setAttribute(\"nonce\", nonce);\n            }\n        }\n        script.type = \"text/javascript\";\n        script.innerHTML = code;\n        let newScriptElement = head.appendChild(script);\n        head.removeChild(newScriptElement);\n        return this;\n    }\n\n    /**\n     * global eval head appendix method\n     * no other methods are supported anymore\n     * @param code the code to be evaled\n     * @param  nonce optional  nonce key for higher security\n     */\n    globalEvalSticky(code: string, nonce ?: string): DomQuery {\n        let head = document.getElementsByTagName(\"head\")[0] || document.documentElement;\n        let script = document.createElement(\"script\");\n        if (nonce) {\n            if ('undefined' != typeof script?.nonce) {\n                script.nonce = nonce;\n            } else {\n                script.setAttribute(\"nonce\", nonce);\n            }\n        }\n        script.type = \"text/javascript\";\n        script.innerHTML = code;\n        head.appendChild(script);\n        return this;\n    }\n\n    /**\n     * detaches a set of nodes from their parent elements\n     * in a browser independend manner\n     * @return {Array} an array of nodes with the detached dom nodes\n     */\n    detach(): DomQuery {\n        this.eachElem((item: Element) => {\n            item.parentNode.removeChild(item);\n        });\n        return this;\n    }\n\n    /**\n     * appends the current set of elements\n     * to the element or first element passed via elem\n     * @param elem\n     */\n    appendTo(elem: DomQuery | string): DomQuery {\n        if (Lang.isString(elem)) {\n            this.appendTo(DomQuery.querySelectorAll(elem as string));\n            return this;\n        }\n        this.eachElem((item) => {\n            let value1: Element = <Element>(elem as DomQuery).getAsElem(0).orElseLazy(() => {\n                return {\n                    appendChild: () => {\n                    }\n                }\n            }).value;\n            value1.appendChild(item);\n        });\n        return this;\n    }\n\n    /**\n     * loads and evals a script from a source uri\n     *\n     * @param src the source to be loaded and evaled\n     * @param defer in miliseconds execution default (0 == no defer)\n     * @param charSet\n     */\n    loadScriptEval(src: string, defer: number = 0, charSet: string = \"utf-8\", nonce?: string) {\n        let srcNode = this.createSourceNode(src, nonce);\n        let head = document.head;\n        if (!defer) {\n            head.appendChild(srcNode);\n            head.removeChild(srcNode);\n        } else {\n            setTimeout(() => {\n                head.appendChild(srcNode);\n                head.removeChild(srcNode);\n            }, defer);\n        }\n\n        return this;\n    }\n\n\n    /**\n     * loads and evals a script from a source uri\n     *\n     * @param src the source to be loaded and evaled\n     * @param defer in miliseconds execution default (0 == no defer)\n     * @param charSet\n     */\n    loadScriptEvalSticky(src: string, defer: number = 0, charSet: string = \"utf-8\", nonce?: string) {\n        let srcNode = this.createSourceNode(src, nonce);\n\n        if (!defer) {\n            document.head.appendChild(srcNode);\n        } else {\n            setTimeout(() => {\n                document.head.appendChild(srcNode);\n            }, defer);\n        }\n\n        return this;\n    }\n\n    insertAfter(...toInsertParams: Array<DomQuery>): DomQuery {\n\n        this.each(existingItem => {\n            let existingElement = existingItem.getAsElem(0).value;\n            let rootNode = existingElement.parentNode;\n            for (let cnt = 0; cnt < toInsertParams.length; cnt++) {\n                let nextSibling: Element = <any>existingElement.nextSibling;\n                toInsertParams[cnt].eachElem(insertElem => {\n                    if (nextSibling) {\n                        rootNode.insertBefore(insertElem, nextSibling);\n                        existingElement = nextSibling;\n                    } else {\n                        rootNode.appendChild(insertElem);\n                    }\n                });\n\n            }\n        });\n\n        let res = [];\n        res.push(this);\n        res = res.concat(toInsertParams);\n        return new DomQuery(...res);\n    }\n\n    insertBefore(...toInsertParams: Array<DomQuery>): DomQuery {\n        this.each(existingItem => {\n            let existingElement = existingItem.getAsElem(0).value;\n            let rootNode = existingElement.parentNode;\n            for (let cnt = 0; cnt < toInsertParams.length; cnt++) {\n                toInsertParams[cnt].eachElem(insertElem => {\n                    rootNode.insertBefore(insertElem, existingElement);\n                });\n            }\n        });\n        let res = [];\n        res.push(this);\n        res = res.concat(toInsertParams);\n        return new DomQuery(...res);\n    }\n\n    orElse(...elseValue: any): DomQuery {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            return new DomQuery(...elseValue);\n        }\n    }\n\n    orElseLazy(func: () => any): DomQuery {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            return new DomQuery(func());\n        }\n    }\n\n    parents(tagName: string): DomQuery {\n        const retSet: Set<Element> = new Set();\n        const retArr: Array<Element> = [];\n        const lowerTagName = tagName.toLowerCase();\n\n        let resolveItem = (item: Element) => {\n            if ((item.tagName || \"\").toLowerCase() == lowerTagName && !retSet.has(item)) {\n                retSet.add(item);\n                retArr.push(item);\n            }\n        };\n\n        this.eachElem((item: Element) => {\n            while (item.parentNode || (<any>item).host) {\n                item = <Element>item?.parentNode ?? (<any>item)?.host;\n\n                resolveItem(item);\n                //nested forms not possible, performance shortcut\n                if (tagName == \"form\" && retArr.length) {\n                    return false;\n                }\n            }\n        });\n\n        return new DomQuery(...retArr);\n    }\n\n    copyAttrs(sourceItem: DomQuery | XMLQuery): DomQuery {\n        sourceItem.eachElem((sourceNode: Element) => {\n            let attrs: Array<Attr> = objToArray(sourceNode.attributes);\n            for (let item of attrs) {\n                let value: string = item.value;\n                let name: string = item.name;\n\n                switch (name) {\n                    case \"id\":\n                        this.id.value = value;\n                        break;\n                    case \"disabled\":\n                        this.resolveAttributeHolder(\"disabled\").disabled = value;\n                        break;\n                    case \"checked\":\n                        this.resolveAttributeHolder(\"checked\").checked = value;\n                        break;\n                    default:\n                        this.attr(name).value = value;\n                }\n            }\n        });\n        return this;\n    }\n\n    /**\n     * resolves an attribute holder compared\n     * @param attrName the attribute name\n     */\n    private resolveAttributeHolder(attrName: string = \"value\"): HTMLFormElement | any {\n        let ret = [];\n        ret[attrName] = null;\n        return (attrName in this.getAsElem(0).value) ?\n            this.getAsElem(0).value :\n            ret;\n    }\n\n    /**\n     * outerhtml convenience method\n     * browsers only support innerHTML but\n     * for instance for your jsf.js we have a full\n     * replace pattern which needs outerHTML processing\n     *\n     * @param markup the markup which should replace the root element\n     * @param runEmbeddedScripts if true the embedded scripts are executed\n     * @param runEmbeddedCss if true the embeddec css are executed\n     * @param deep should this also work for shadow dom (run scripts etc...)\n     */\n    outerHTML(markup: string, runEmbeddedScripts ?: boolean, runEmbeddedCss ?: boolean, deep = false): DomQuery {\n        if (this.isAbsent()) {\n            return;\n        }\n\n        let focusElementId = document?.activeElement?.id;\n        let caretPosition = (focusElementId) ? DomQuery.getCaretPosition(document.activeElement) : null;\n        let nodes = DomQuery.fromMarkup(markup);\n        let res = [];\n        let toReplace = this.getAsElem(0).value;\n        let firstInsert = nodes.get(0);\n        let parentNode = toReplace.parentNode;\n        let replaced = firstInsert.getAsElem(0).value;\n        parentNode.replaceChild(replaced, toReplace);\n        res.push(new DomQuery(replaced));\n        //no replacement possible\n        if (this.isAbsent()) {\n            return this;\n        }\n\n        let insertAdditionalItems = [];\n\n        if (nodes.length > 1) {\n            insertAdditionalItems = insertAdditionalItems.concat(...nodes.values.slice(1));\n            res.push(DomQuery.byId(replaced).insertAfter(new DomQuery(...insertAdditionalItems)));\n        }\n\n        if (runEmbeddedScripts) {\n            this.runScripts();\n        }\n        if (runEmbeddedCss) {\n            this.runCss();\n        }\n\n        let focusElement = DomQuery.byId(focusElementId);\n        if (focusElementId && focusElement.isPresent() &&\n            caretPosition != null && \"undefined\" != typeof caretPosition) {\n            focusElement.eachElem(item => DomQuery.setCaretPosition(item, caretPosition));\n        }\n\n        return nodes;\n    }\n\n    /**\n     * Run through the given nodes in the DomQuery execute the inline scripts\n     * @param sticky if set to true the evaled elements will stick to the head, default false\n     * @param whilteListed: optional whitelist function which can filter out script tags which are not processed\n     * defaults to the standard jsf.js exclusion (we use this code for myfaces)\n     */\n    runScripts(sticky = false, whilteListed: (val: string) => boolean = DEFAULT_WHITELIST): DomQuery {\n        const evalCollectedScripts = (scriptsToProcess: { evalText: string, nonce: string }[]) => {\n            if (scriptsToProcess.length) {\n                //script source means we have to eval the existing\n                //scripts before running the include\n                //this.globalEval(finalScripts.join(\"\\n\"));\n                let joinedScripts = [];\n                Stream.of(...scriptsToProcess).each(item => {\n                    if (!item.nonce) {\n                        joinedScripts.push(item.evalText)\n                    } else {\n                        if (joinedScripts.length) {\n                            this.globalEval(joinedScripts.join(\"\\n\"));\n                            joinedScripts.length = 0;\n                        }\n\n                        (!sticky) ?\n                            this.globalEval(item.evalText, item.nonce) :\n                            this.globalEvalSticky(item.evalText, item.nonce);\n                    }\n                });\n                if (joinedScripts.length) {\n                    (!sticky) ? this.globalEval(joinedScripts.join(\"\\n\")) :\n                        this.globalEvalSticky(joinedScripts.join(\"\\n\"));\n                    joinedScripts.length = 0;\n                }\n\n                scriptsToProcess = [];\n            }\n            return scriptsToProcess;\n        }\n\n        let finalScripts = [],\n            equi = equalsIgnoreCase,\n            execScrpt = (item) => {\n                let tagName = item.tagName;\n                let itemType = item.type || \"\";\n                if (tagName && equi(tagName, \"script\") &&\n                    (itemType === \"\" || equi(itemType, \"text/javascript\") ||\n                        equi(itemType, \"javascript\") ||\n                        equi(itemType, \"text/ecmascript\") ||\n                        equi(itemType, \"ecmascript\"))) {\n                    let src = item.getAttribute('src');\n                    if ('undefined' != typeof src\n                        && null != src\n                        && src.length > 0\n                    ) {\n                        let nonce = item?.nonce ?? item.getAttribute('nonce').value;\n                        //we have to move this into an inner if because chrome otherwise chokes\n                        //due to changing the and order instead of relying on left to right\n                        //if jsf.js is already registered we do not replace it anymore\n                        if (whilteListed(src)) {\n                            //we run the collected scripts before running, the include\n                            finalScripts = evalCollectedScripts(finalScripts);\n                            if (!sticky) {\n                                (!!nonce) ? this.loadScriptEval(src, 0, \"UTF-8\", nonce) :\n                                    //if no nonce is set we do not pass any once\n                                    this.loadScriptEval(src, 0, \"UTF-8\");\n                            } else {\n                                (!!nonce) ? this.loadScriptEvalSticky(src, 0, \"UTF-8\", nonce) :\n                                    //if no nonce is set we do not pass any once\n                                    this.loadScriptEvalSticky(src, 0, \"UTF-8\");\n                            }\n                        }\n\n                    } else {\n                        // embedded script auto eval\n                        //TODO this probably needs to be changed due to our new parsing structures\n                        //probably not needed anymore\n                        let evalText = trim(item.text || item.innerText || item.innerHTML);\n                        let go = true;\n\n                        while (go) {\n                            go = false;\n                            if (evalText.substring(0, 4) == \"<!--\") {\n                                evalText = evalText.substring(4);\n                                go = true;\n                            }\n                            if (evalText.substring(0, 4) == \"//<!--\") {\n                                evalText = evalText.substring(6);\n                                go = true;\n                            }\n                            if (evalText.substring(0, 11) == \"//<![CDATA[\") {\n                                evalText = evalText.substring(11);\n                                go = true;\n                            }\n                        }\n                        let nonce = item?.nonce ?? item.getAttribute('nonce').value ?? '';\n                        // we have to run the script under a global context\n                        //we store the script for less calls to eval\n                        finalScripts.push({\n                            nonce,\n                            evalText\n                        });\n                    }\n                }\n            };\n        try {\n            let scriptElements = new DomQuery(this.filterSelector(\"script\"), this.querySelectorAll(\"script\"));\n            //script execution order by relative pos in their dom tree\n            scriptElements.stream\n                .flatMap(item => Stream.of(item.values))\n                .sort((node1, node2) => node1.compareDocumentPosition(node2) - 3) //preceding 2, following == 4)\n                .each(item => execScrpt(item));\n\n            evalCollectedScripts(finalScripts);\n        } catch (e) {\n            if (console && console.error) {\n                //not sure if we\n                //should use our standard\n                //error mechanisms here\n                //because in the head appendix\n                //method only a console\n                //error would be raised as well\n                console.error(e.message || e.description);\n            }\n        } finally {\n            //the usual ie6 fix code\n            //the IE6 garbage collector is broken\n            //nulling closures helps somewhat to reduce\n            //mem leaks, which are impossible to avoid\n            //at this browser\n            execScrpt = null;\n        }\n        return this;\n    }\n\n    runCss(): DomQuery {\n\n        const applyStyle = (item: Element, style: string) => {\n                let newSS: HTMLStyleElement = document.createElement(\"style\");\n                document.getElementsByTagName(\"head\")[0].appendChild(newSS);\n\n                let styleSheet = newSS.sheet ?? (<any>newSS).styleSheet;\n\n                newSS.setAttribute(\"rel\", item.getAttribute(\"rel\") ?? \"stylesheet\");\n                newSS.setAttribute(\"type\", item.getAttribute(\"type\") ?? \"text/css\");\n\n                if (styleSheet?.cssText ?? false) {\n                    styleSheet.cssText = style;\n                } else {\n                    newSS.appendChild(document.createTextNode(style));\n                }\n            },\n\n            execCss = (item: Element) => {\n                const tagName = item.tagName;\n                if (tagName && equalsIgnoreCase(tagName, \"link\") && equalsIgnoreCase(item.getAttribute(\"type\"), \"text/css\")) {\n                    applyStyle(item, \"@import url('\" + item.getAttribute(\"href\") + \"');\");\n                } else if (tagName && equalsIgnoreCase(tagName, \"style\") && equalsIgnoreCase(item.getAttribute(\"type\"), \"text/css\")) {\n                    let innerText = [];\n                    //compliant browsers know child nodes\n                    let childNodes: Array<Node> = Array.prototype.slice.call(item.childNodes);\n                    if (childNodes) {\n                        childNodes.forEach(child => innerText.push((<Element>child).innerHTML || (<CharacterData>child).data));\n                        //non compliant ones innerHTML\n                    } else if (item.innerHTML) {\n                        innerText.push(item.innerHTML);\n                    }\n\n                    applyStyle(item, innerText.join(\"\"));\n                }\n            };\n\n        const scriptElements: DomQuery = new DomQuery(this.filterSelector(\"link, style\"), this.querySelectorAll(\"link, style\"));\n\n        scriptElements.stream\n            .flatMap(item => Stream.of(item.values))\n            .sort((node1, node2) => node1.compareDocumentPosition(node2) - 3)\n            .each(item => execCss(item));\n\n        return this;\n    }\n\n    /**\n     * fires a click event on the underlying dom elements\n     */\n    click(): DomQuery {\n        this.fireEvent(\"click\");\n        return this;\n    }\n\n    addEventListener(type: string, listener: (evt: Event) => void, options?: boolean | EventListenerOptions): DomQuery {\n        this.eachElem((node: Element) => node.addEventListener(type, listener, options));\n        return this;\n    }\n\n    removeEventListener(type: string, listener: (evt: Event) => void, options?: boolean | EventListenerOptions): DomQuery {\n        this.eachElem((node: Element) => node.removeEventListener(type, listener, options));\n        return this;\n    }\n\n    /**\n     * fires an event\n     */\n    fireEvent(eventName: string) {\n        this.eachElem((node: Element) => {\n            let doc;\n            if (node.ownerDocument) {\n                doc = node.ownerDocument;\n            } else if (node.nodeType == 9) {\n                // the node may be the document itself, nodeType 9 = DOCUMENT_NODE\n                doc = node;\n            } else {\n                throw new Error(\"Invalid node passed to fireEvent: \" + node.id);\n            }\n\n            if (node.dispatchEvent) {\n                // Gecko-style approach (now the standard) takes more work\n                let eventClass = \"\";\n\n                // Different events have different event classes.\n                // If this switch statement can't map an eventName to an eventClass,\n                // the event firing is going to fail.\n                switch (eventName) {\n                    case \"click\": // Dispatching of 'click' appears to not work correctly in Safari. Use 'mousedown' or 'mouseup' instead.\n                    case \"mousedown\":\n                    case \"mouseup\":\n                        eventClass = \"MouseEvents\";\n                        break;\n\n                    case \"focus\":\n                    case \"change\":\n                    case \"blur\":\n                    case \"select\":\n                        eventClass = \"HTMLEvents\";\n                        break;\n\n                    default:\n                        throw \"fireEvent: Couldn't find an event class for event '\" + eventName + \"'.\";\n                }\n                let event = doc.createEvent(eventClass);\n                event.initEvent(eventName, true, true); // All events created as bubbling and cancelable.\n\n                event.synthetic = true; // allow detection of synthetic events\n                // The second parameter says go ahead with the default action\n                node.dispatchEvent(event);\n            } else if ((<any>node).fireEvent) {\n                // IE-old school style, you can drop this if you don't need to support IE8 and lower\n                let event = doc.createEventObject();\n                event.synthetic = true; // allow detection of synthetic events\n                (<any>node).fireEvent(\"on\" + eventName, event);\n            }\n        })\n    }\n\n    textContent(joinstr: string = \"\"): string {\n        return this.stream\n            .map((value: DomQuery) => {\n                let item = value.getAsElem(0).orElseLazy(() => {\n                    return <any>{\n                        textContent: \"\"\n                    };\n                }).value;\n                return (<any>item).textContent || \"\";\n            })\n            .reduce((text1, text2) => text1 + joinstr + text2, \"\").value;\n    }\n\n    innerText(joinstr: string = \"\"): string {\n        return this.stream\n            .map((value: DomQuery) => {\n                let item = value.getAsElem(0).orElseLazy(() => {\n                    return <any>{\n                        innerText: \"\"\n                    };\n                }).value;\n                return (<any>item).innerText || \"\";\n            })\n            .reduce((text1, text2) => [text1, text2].join(joinstr), \"\").value;\n\n    }\n\n    /**\n     * encodes all input elements properly into respective\n     * config entries, this can be used\n     * for legacy systems, for newer usecases, use the\n     * HTML5 Form class which all newer browsers provide\n     *\n     * @param toMerge optional config which can be merged in\n     * @return a copy pf\n     */\n    encodeFormElement(toMerge = new Config({})): Config {\n\n        //browser behavior no element name no encoding (normal submit fails in that case)\n        //https://issues.apache.org/jira/browse/MYFACES-2847\n        if (this.name.isAbsent()) {\n            return;\n        }\n\n        //lets keep it sideffects free\n        let target = toMerge.shallowCopy;\n\n        this.each((element: DomQuery) => {\n            if (element.name.isAbsent()) {//no name, no encoding\n                return;\n            }\n            let name = element.name.value;\n            let tagName = element.tagName.orElse(\"__none__\").value.toLowerCase();\n            let elemType = element.type.orElse(\"__none__\").value.toLowerCase();\n\n            elemType = elemType.toLowerCase();\n\n            // routine for all elements\n            // rules:\n            // - process only inputs, textareas and selects\n            // - elements muest have attribute \"name\"\n            // - elements must not be disabled\n            if (((tagName == \"input\" || tagName == \"textarea\" || tagName == \"select\") &&\n                (name != null && name != \"\")) && !element.disabled) {\n\n                // routine for select elements\n                // rules:\n                // - if select-one and value-Attribute exist => \"name=value\"\n                // (also if value empty => \"name=\")\n                // - if select-one and value-Attribute don't exist =>\n                // \"name=DisplayValue\"\n                // - if select multi and multple selected => \"name=value1&name=value2\"\n                // - if select and selectedIndex=-1 don't submit\n                if (tagName == \"select\") {\n                    // selectedIndex must be >= 0 sein to be submittet\n                    let selectElem: HTMLSelectElement = <HTMLSelectElement>element.getAsElem(0).value;\n                    if (selectElem.selectedIndex >= 0) {\n                        let uLen = selectElem.options.length;\n                        for (let u = 0; u < uLen; u++) {\n                            // find all selected options\n                            //let subBuf = [];\n                            if (selectElem.options[u].selected) {\n                                let elementOption = selectElem.options[u];\n                                target.append(name).value = (elementOption.getAttribute(\"value\") != null) ?\n                                    elementOption.value : elementOption.text;\n                            }\n                        }\n                    }\n                }\n\n                // routine for remaining elements\n                // rules:\n                // - don't submit no selects (processed above), buttons, reset buttons, submit buttons,\n                // - submit checkboxes and radio inputs only if checked\n                if (\n                    (\n                        tagName != Submittables.SELECT &&\n                        elemType != Submittables.BUTTON &&\n                        elemType != Submittables.RESET &&\n                        elemType != Submittables.SUBMIT &&\n                        elemType != Submittables.IMAGE\n                    ) && (\n                        (\n                            elemType != Submittables.CHECKBOX && elemType != Submittables.RADIO) ||\n                        element.checked\n                    )\n                ) {\n                    let files: any = (<any>element.value).value?.files ?? [];\n                    if (files?.length) {\n                        //xhr level2\n                        target.append(name).value = files[0];\n                    } else {\n                        target.append(name).value = element.inputValue.value;\n                    }\n                }\n\n            }\n        });\n\n        return target;\n    }\n\n    get cDATAAsString(): string {\n        let TYPE_CDATA_BLOCK = 4;\n\n        let res: any = this.lazyStream.flatMap(item => {\n            return item.childNodes.stream\n        }).filter(item => {\n            return item?.value?.value?.nodeType == TYPE_CDATA_BLOCK;\n        }).reduce((reduced: Array<any>, item: DomQuery) => {\n            reduced.push((<any>item?.value?.value)?.data ?? \"\");\n            return reduced;\n        }, []).value;\n\n        // response may contain several blocks\n        return res.join(\"\");\n    }\n\n    subNodes(from: number, to?: number): DomQuery {\n        if (Optional.fromNullable(to).isAbsent()) {\n            to = this.length;\n        }\n        return new DomQuery(...this.rootNode.slice(from, Math.min(to, this.length)));\n    }\n\n    //TODO this part probably will be removed\n    //because we can stream from an array stream directly into the dom query\n    _limits = -1;\n\n    limits(end: number): IStream<DomQuery> {\n        this._limits = end;\n        return <any>this;\n    }\n\n    //-- internally exposed methods needed for the interconnectivity\n    hasNext() {\n        let isLimitsReached = this._limits != -1 && this.pos >= this._limits - 1;\n        let isEndOfArray = this.pos >= this.values.length - 1;\n        return !(isLimitsReached ||\n            isEndOfArray);\n    }\n\n    next(): DomQuery {\n        if (!this.hasNext()) {\n            return null;\n        }\n        this.pos++;\n        return new DomQuery(this.values[this.pos]);\n    }\n\n\n    lookAhead(cnt = 1): ITERATION_STATUS | DomQuery {\n        if ((this.values.length - 1) < (this.pos + cnt)) {\n            return ITERATION_STATUS.EO_STRM;\n        }\n        return new DomQuery(this.values[this.pos + cnt]);\n    }\n\n\n    current(): DomQuery | ITERATION_STATUS {\n        if (this.pos == -1) {\n            return ITERATION_STATUS.BEF_STRM;\n        }\n        return new DomQuery(this.values[this.pos]);\n    }\n\n\n    reset() {\n        this.pos = -1;\n    }\n\n    attachShadow(params: { [key: string]: string } = {mode: \"open\"}): DomQuery {\n        let shadowRoots: DomQuery[] = [];\n        this.eachElem((item: Element) => {\n            let shadowElement: DomQuery;\n            if ((<any>item)?.attachShadow) {\n                shadowElement = DomQuery.byId((<any>item).attachShadow(params));\n                shadowRoots.push(shadowElement);\n            } else {\n                throw new Error(\"Shadow dom creation not supported by the browser, please use a shim, to gain this functionality\");\n            }\n        });\n        return new DomQuery(...shadowRoots);\n    }\n\n    /**\n     * helper to fix a common dom problem\n     * we have to wait until a certain condition is met, in most of the cases we just want to know whether an element is present in the subdome before being able to proceed\n     * @param condition\n     * @param options\n     */\n    async waitUntilDom(condition: (element: DomQuery) => boolean, options: WAIT_OPTS = {\n        attributes: true,\n        childList: true,\n        subtree: true,\n        timeout: 500,\n        interval: 100\n    }): Promise<DomQuery> {\n        return waitUntilDom(this, condition, options);\n    }\n\n    /**\n     * returns the embedded shadow elements\n     */\n    get shadowElements(): DomQuery {\n        let shadowElements = this.querySelectorAll(\"*\")\n            .filter(item => item.hasShadow);\n\n\n        let mapped: Array<ShadowRoot> = (shadowElements.allElems() || []).map(element => element.shadowRoot);\n        return new DomQuery(...mapped);\n    }\n\n    get shadowRoot(): DomQuery {\n        let shadowRoots = [];\n        for (let cnt = 0; cnt < this.rootNode.length; cnt++) {\n            if (this.rootNode[cnt].shadowRoot) {\n                shadowRoots.push(this.rootNode[cnt].shadowRoot);\n            }\n        }\n        return new DomQuery(...shadowRoots);\n    }\n\n    get hasShadow(): boolean {\n        for (let cnt = 0; cnt < this.rootNode.length; cnt++) {\n            if (this.rootNode[cnt].shadowRoot) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //from\n    // http://blog.vishalon.net/index.php/javascript-getting-and-setting-caret-position-in-textarea/\n    static getCaretPosition(ctrl: any) {\n        let caretPos = 0;\n\n        try {\n            if ((<any>document)?.selection) {\n                ctrl.focus();\n                let selection = (<any>document).selection.createRange();\n                //the selection now is start zero\n                selection.moveStart('character', -ctrl.value.length);\n                //the caretposition is the selection start\n                caretPos = selection.text.length;\n            }\n        } catch (e) {\n            //now this is ugly, but not supported input types throw errors for selectionStart\n            //just in case someone dumps this code onto unsupported browsers\n        }\n        return caretPos;\n    }\n\n    /**\n     * sets the caret position\n     *\n     * @param ctrl the control to set the caret position to\n     * @param pos the position to set\n     *\n     * note if the control does not have any selectable and focusable behavior\n     * calling this method does nothing (silent fail)\n     *\n     */\n    static setCaretPosition(ctrl: any, pos: number) {\n        ctrl?.focus ? ctrl?.focus() : null;\n        //the selection range is our caret position\n\n        ctrl?.setSelectiongRange ? ctrl?.setSelectiongRange(pos, pos) : null;\n    }\n\n    /**\n     * Implementation of an iterator\n     * to allow loops over dom query collections\n     */\n    [Symbol.iterator](): Iterator<DomQuery, any, undefined> {\n        return {\n            next: () => {\n                let done = !this.hasNext();\n                let val = this.next();\n                return {\n                    done: done,\n                    value: <DomQuery>val\n                }\n            }\n        }\n    }\n\n    /**\n     * concats the elements of two Dom Queries into a single one\n     * @param toAttach the elements to attach\n     * @param filterDoubles filter out possible double elements (aka same markup)\n     */\n    concat(toAttach: DomQuery, filterDoubles = true): any {\n        const ret = this.lazyStream.concat(toAttach.lazyStream).collect(new DomQueryCollector());\n        //we now filter the doubles out\n        if (!filterDoubles) {\n            return ret;\n        }\n        let idx = {}; //ie11 does not support sets, we have to fake it\n        return ret.lazyStream.filter(node => {\n            const notFound = !(idx?.[node.value.value.outerHTML as any]);\n            idx[node.value.value.outerHTML as any] = true;\n            return notFound;\n        }).collect(new DomQueryCollector());\n    }\n\n    append(elem: DomQuery): DomQuery {\n        this.each(item => elem.appendTo(item));\n        return this;\n    }\n\n    prependTo(elem: DomQuery): DomQuery {\n        elem.eachElem(item => {\n            item.prepend(...this.allElems());\n        });\n        return this;\n    }\n\n    prepend(elem: DomQuery): DomQuery {\n        this.eachElem(item => {\n            item.prepend(...elem.allElems());\n        })\n        return this;\n    }\n\n\n    /*[observable](): Observable<DomQuery> {\n        return this.observable;\n    }\n\n    get observable(): Observable<DomQuery> {\n        let observerFunc = (observer:Subscriber<DomQuery>) => {\n            try {\n                this.each(dqNode => {\n                    observer.next(dqNode);\n                });\n            } catch (e) {\n                observer.error(e);\n            }\n        };\n        return new Observable(observerFunc);\n    }\n\n    get observableElem(): Observable<Element> {\n        let observerFunc = (observer:Subscriber<Element>) => {\n            try {\n                this.eachElem(node => {\n                    observer.next(node);\n                });\n            } catch (e) {\n                observer.error(e);\n            }\n        };\n        return new Observable(observerFunc);\n    }*/\n\n    private createSourceNode(src, nonce?:string) {\n        let srcNode: HTMLScriptElement = document.createElement(\"script\");\n        srcNode.type = \"text/javascript\";\n        if (!!nonce) {\n            if ('undefined' != typeof srcNode?.nonce) {\n                srcNode.nonce = nonce;\n            } else {\n                srcNode.setAttribute(\"nonce\", nonce);\n            }\n        }\n        srcNode.src = src;\n        return srcNode;\n    }\n\n}\n\n\n/**\n * Various collectors\n * which can be used in conjunction with Streams\n */\n\n/**\n * A collector which bundles a full dom query stream into a single dom query element\n *\n * This connects basically our stream back into DomQuery\n */\nexport class DomQueryCollector implements ICollector<DomQuery, DomQuery> {\n\n    data: DomQuery[] = [];\n\n    collect(element: DomQuery) {\n        this.data.push(element);\n    }\n\n    get finalValue(): DomQuery {\n        return new DomQuery(...this.data);\n    }\n}\n\n/**\n * abbreviation for DomQuery\n */\nexport const DQ = DomQuery;\nexport type DQ = DomQuery;\n// noinspection JSUnusedGlobalSymbols\n/**\n * replacement for the jquery $\n */\nexport const DQ$ = DomQuery.querySelectorAll;\n","/*!\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n * various environments handle the global variable different\n * we have to deal with this.\n */\nexport function _global$(): any | null {\n    let _global$: any =  ('undefined' != typeof globalThis && globalThis.window) ? globalThis.window:\n        ('undefined' != typeof window) ? window :\n            ('undefined' != typeof globalThis) ? globalThis :\n                ('undefined' != typeof global && global?.window) ? global.window :\n                    ('undefined' != typeof global) ? global : null;\n    //under test systems we often have a lazy init of the window object under global.window, but we\n    //want the window object\n    return _global$?.window ?? _global$;\n}\n\n","/*!\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Optional} from \"./Monad\";\n\n/**\n * Lang helpers crossported from the apache myfaces project\n */\nexport module Lang {\n    \n\n    //should be in lang, but for now here to avoid recursive imports, not sure if typescript still has a problem with those\n    /**\n     * helper function to savely resolve anything\n     * this is not an elvis operator, it resolves\n     * a value without exception in a tree and if\n     * it is not resolvable then an optional of\n     * a default value is restored or Optional.empty\n     * if none is given\n     *\n     * usage\n     * <code>\n     *     let var: Optiona<string> = saveResolve(() => a.b.c.d.e, \"foobaz\")\n     * </code>\n     *\n     * @param resolverProducer a lambda which can produce the value\n     * @param defaultValue an optional default value if the producer failes to produce anything\n     * @returns an Optional of the produced value\n     */\n    export function saveResolve<T>(resolverProducer: () => T, defaultValue: T = null): Optional<T> {\n        try {\n            let result = resolverProducer();\n            return Optional.fromNullable(result ?? defaultValue);\n        } catch (e) {\n            return Optional.absent;\n        }\n    }\n\n    export function saveResolveLazy<T>(resolverProducer: () => T, defaultValue: () => T = null): Optional<T> {\n        try {\n            let result = resolverProducer();\n            return Optional.fromNullable(result ?? defaultValue());\n        } catch (e) {\n            return Optional.absent;\n        }\n    }\n\n    /**\n     * String to array function performs a string to array transformation\n     * @param {String} it the string which has to be changed into an array\n     * @param {RegExp} splitter our splitter reglar expression\n     * @return a trimmed array of the splitted string\n     */\n    export function strToArray(it: string, splitter: string | RegExp = /\\./gi): Array<string> {\n\n        let ret = [];\n        it.split(splitter).forEach((element => {\n            ret.push(trim(element));\n        }));\n        return ret;\n    }\n\n    /**\n     * hyperfast trim\n     * http://blog.stevenlevithan.com/archives/faster-trim-javascript\n     * crossported from dojo\n     */\n    export function trim(str: string): string {\n        str = str.replace(/^\\s\\s*/, '');\n        let ws = /\\s/, i = str.length;\n\n        while (ws.test(str.charAt(--i))) {\n            //do nothing\n        }\n        return str.slice(0, i + 1);\n    }\n\n    /**\n     * generic object arrays like dom definitions to array conversion method which\n     * transforms any object to something array like\n     * @param obj\n     * @param offset\n     * @param pack\n     * @returns an array converted from the object\n     */\n    export function objToArray<T>(obj: any, offset: number = 0, pack: Array<T> = []): Array<T> {\n        if ((obj ?? \"__undefined__\") == \"__undefined__\") {\n            return pack ?? null;\n        }\n        //since offset is numeric we cannot use the shortcut due to 0 being false\n        //special condition array delivered no offset no pack\n        if ((<any>obj) instanceof Array && !offset && !pack) return obj;\n\n        return pack.concat(Array.prototype.slice.call(obj, offset));\n    }\n\n    /**\n     * equalsIgnoreCase, case insensitive comparison of two strings\n     *\n     * @param source\n     * @param destination\n     */\n    export function equalsIgnoreCase(source?: string, destination?: string): boolean {\n        let finalSource = source ?? \"___no_value__\";\n        let finalDest = destination ?? \"___no_value__\";\n\n        //in any other case we do a strong string comparison\n        return finalSource.toLowerCase() === finalDest.toLowerCase();\n    }\n\n\n    /**\n     * runtime type assertion\n     *\n     * @param probe the probe to be tested for a type\n     * @param theType the type to be tested for\n     */\n    export function assertType(probe: any, theType: any): boolean {\n        return isString(theType) ? typeof probe == theType : probe instanceof theType;\n    }\n\n    /**\n     * Backported from dojo\n     * a failsafe string determination method\n     * (since in javascript String != \"\" typeof alone fails!)\n     * @param it {|Object|} the object to be checked for being a string\n     * @return true in case of being a string false otherwise\n     */\n    export function isString(it?: any): boolean {\n        //\tsummary:\n        //\t\tReturn true if it is a String\n        return !!arguments.length && it != null && (typeof it == \"string\" || it instanceof String); // Boolean\n    }\n\n    export function isFunc(it: any): boolean {\n        return it instanceof Function || typeof it === \"function\";\n    }\n\n    // code from https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    // license https://creativecommons.org/licenses/by-sa/2.5/\n    export function objAssign(target: any, ...theArgs: any) { // .length of function is 2\n        if (target == null) { // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        let to = Object(target);\n        if((<any>Object).assign) {\n            theArgs.forEach(item => (<any>Object).assign(to, item));\n            return to;\n        }\n\n        theArgs.filter(item => item != null).forEach(item => {\n            let nextSource = item;\n            Object.keys(nextSource)\n                .filter(nextKey => Object.prototype.hasOwnProperty.call(nextSource, nextKey))\n                .forEach(nextKey => to[nextKey] = nextSource[nextKey]);\n        });\n        return to;\n    }\n\n\n}\n\n","/*!\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A module which keeps  basic monadish like definitions in place without any sidedependencies to other modules.\n * Useful if you need the functions in another library to keep its dependencies down\n */\n\n/*IMonad definitions*/\n\nimport {Lang} from \"./Lang\";\nimport {AssocArrayCollector} from \"./SourcesCollectors\";\nimport {Stream} from \"./Stream\";\nimport objAssign = Lang.objAssign;\n\n/**\n * IFunctor interface,\n * defines an interface which allows to map a functor\n * via a first order function to another functor\n */\nexport interface IFunctor<T> {\n    map<R>(fn: (data: T) => R): IFunctor<R>;\n}\n\n/**\n * IMonad definition, basically a functor with a flaptmap implementation (flatmap reduces all nested monads after a\n * function call f into a monad with the nesting level of 1\n *\n * flatmap flats nested Monads into a IMonad of the deepest nested implementation\n */\nexport interface IMonad<T, M extends IMonad<any, any>> extends IFunctor<T> {\n    flatMap<T, M>(f: (T) => M): IMonad<any, any>;\n}\n\n/**\n * a stateful functor which holds a value upn which a\n * function can be applied\n *\n * as value holder of type T\n */\nexport interface IIdentity<T> extends IFunctor<T> {\n    readonly value: T;\n}\n\n/**\n *  custom value holder definition, since we are not pure functional\n *  but iterative we have structures which allow the assignment of a value\n *  also not all structures are sideffect free\n */\nexport interface IValueHolder<T> {\n    value: T | Array<T>;\n}\n\n/**\n * Implementation of a monad\n * (Sideffect free), no write allowed directly on the monads\n * value state\n */\nexport class Monad<T> implements IMonad<T, Monad<any>>, IValueHolder<T> {\n    constructor(value: T) {\n        this._value = value;\n    }\n\n    protected _value: T;\n\n    get value(): T {\n        return this._value;\n    }\n\n    map<R>(fn?: (data: T) => R): Monad<R> {\n        if (!fn) {\n            fn = (inval: any) => <R>inval;\n        }\n        let result: R = fn(this.value);\n        return new Monad(result);\n    }\n\n    flatMap<R>(fn?: (data: T) => R): Monad<any> {\n        let mapped: Monad<any> = this.map(fn);\n        while (mapped?.value instanceof Monad) {\n            mapped = mapped.value\n        }\n        return mapped;\n    }\n\n}\n\n/**\n * optional implementation, an optional is basically an implementation of a Monad with additional syntactic\n * sugar on top\n * (Sideeffect free, since value assignment is not allowed)\n * */\nexport class Optional<T> extends Monad<T> {\n\n    /*default value for absent*/\n    static absent = Optional.fromNullable(null);\n\n    constructor(value: T) {\n        super(value);\n    }\n\n    get value(): T {\n        if (this._value instanceof Monad) {\n            return this._value.flatMap().value\n        }\n        return this._value;\n    }\n\n    static fromNullable<V extends Optional<T>, T>(value?: T): Optional<T> {\n        return <V> new Optional(value);\n    }\n\n    /*syntactic sugar for absent and present checks*/\n    isAbsent(): boolean {\n        return \"undefined\" == typeof this.value || null == this.value;\n    }\n\n    /**\n     * any value present\n     */\n    isPresent(presentRunnable ?: (val ?: Monad<T>) => void): boolean {\n        let absent = this.isAbsent();\n        if (!absent && presentRunnable) {\n            presentRunnable.call(this, this)\n        }\n        return !absent;\n    }\n\n    ifPresentLazy(presentRunnable: (val ?: Monad<T>) => void = () => {\n    }): Monad<T> {\n        this.isPresent.call(this, presentRunnable);\n        return this;\n    }\n\n    orElse(elseValue: any): Optional<any> {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            //shortcut\n            if (elseValue == null) {\n                return Optional.absent;\n            }\n            return this.flatMap(() => elseValue);\n        }\n    }\n\n    /**\n     * lazy, passes a function which then is lazily evaluated\n     * instead of a direct value\n     * @param func\n     */\n    orElseLazy(func: () => any): Optional<any> {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            return this.flatMap(func);\n        }\n    }\n\n    /*\n     * we need to implement it to fullfill the contract, although it is used only internally\n     * all values are flattened when accessed anyway, so there is no need to call this methiod\n     */\n    flatMap<R>(fn?: (data: T) => R): Optional<any> {\n        let val = super.flatMap(fn);\n        if (!(val instanceof Optional)) {\n            return Optional.fromNullable(val.value);\n        }\n\n        return <Optional<any>>val.flatMap();\n    }\n\n    /*\n     * elvis operation, take care, if you use this you lose typesafety and refactoring\n     * capabilites, unfortunately typesceript does not allow to have its own elvis operator\n     * this is some syntactic sugar however which is quite useful*/\n    getIf<R>(...key: string[]): Optional<R> {\n\n        let currentPos: Optional<any> = this;\n        for (let cnt = 0; cnt < key.length; cnt++) {\n            let currKey = this.keyVal(key[cnt]);\n            let arrPos = this.arrayIndex(key[cnt]);\n\n            if (currKey === \"\" && arrPos >= 0) {\n                currentPos = this.getClass().fromNullable(!(currentPos.value instanceof Array) ? null : (currentPos.value.length < arrPos ? null : currentPos.value[arrPos]));\n                if (currentPos.isAbsent()) {\n                    return currentPos;\n                }\n                continue;\n            } else if (currKey && arrPos >= 0) {\n                if (currentPos.getIfPresent(currKey).isAbsent()) {\n                    return currentPos;\n                }\n                currentPos = (currentPos.getIfPresent(currKey).value instanceof Array) ? this.getClass().fromNullable(currentPos.getIfPresent(currKey).value[arrPos]) : this.getClass().absent;\n                if (currentPos.isAbsent()) {\n                    return currentPos;\n                }\n                continue;\n\n            } else {\n                currentPos = currentPos.getIfPresent(currKey);\n            }\n            if (currentPos.isAbsent()) {\n                return currentPos;\n            } else if (arrPos > -1) {\n                currentPos = this.getClass().fromNullable(currentPos.value[arrPos]);\n            }\n        }\n        let retVal = currentPos;\n\n        return retVal;\n    }\n\n    /**\n     * simple match, if the first order function call returns\n     * true then there is a match, if the value is not present\n     * it never matches\n     *\n     * @param fn the first order function performing the match\n     */\n    match(fn: (item: T) => boolean): boolean {\n        if (this.isAbsent()) {\n            return false\n        }\n        return fn(this.value);\n    }\n\n    /**\n     * convenience function to flatmap the internal value\n     * and replace it with a default in case of being absent\n     *\n     * @param defaultVal\n     * @returns {Optional<any>}\n     */\n    get<R>(defaultVal: any = Optional.absent): Optional<R> {\n        if (this.isAbsent()) {\n            return this.getClass().fromNullable(defaultVal).flatMap();\n        }\n\n        return this.getClass().fromNullable(this.value).flatMap();\n    }\n\n    toJson(): string {\n        return JSON.stringify(this.value);\n    }\n\n    /**\n     * helper to override several implementations in a more fluent way\n     * by having a getClass operation we can avoid direct calls into the constructor or\n     * static methods and do not have to implement several methods which rely on the type\n     * of \"this\"\n     * @returns {Monadish.Optional}\n     */\n    protected getClass(): any {\n        return Optional;\n    }\n\n    /*helper method for getIf with array access aka <name>[<indexPos>]*/\n    protected arrayIndex(key: string): number {\n        let start = key.indexOf(\"[\");\n        let end = key.indexOf(\"]\");\n        if (start >= 0 && end > 0 && start < end) {\n            return parseInt(key.substring(start + 1, end));\n        } else {\n            return -1;\n        }\n    }\n\n    /*helper method for getIf with array access aka <name>[<indexPos>]*/\n    protected keyVal(key: string): string {\n        let start = key.indexOf(\"[\");\n\n        if (start >= 0) {\n            return key.substring(0, start);\n        } else {\n            return key;\n        }\n    }\n\n    /**\n     * additional syntactic sugar which is not part of the usual optional implementation\n     * but makes life easier, if you want to sacrifice typesafety and refactoring\n     * capabilities in typescript\n     */\n    getIfPresent<R>(key: string): Optional<R> {\n        if (this.isAbsent()) {\n            return this.getClass().absent;\n        }\n        return this.getClass().fromNullable(this.value[key]).flatMap();\n    }\n\n    /**\n     * elvis like typesafe functional save resolver\n     * a typesafe option for getIfPresent\n     *\n     * usage myOptional.resolve(value => value.subAttr.subAttr2).orElseLazy(....)\n     * if this is resolvable without any errors an Optional with the value is returned\n     * if not, then an Optional absent is returned, also if you return Optional absent\n     * it is flatmapped into absent\n     *\n     * @param resolver the resolver function, can throw any arbitrary errors, int  the error case\n     * the resolution goes towards absent\n     */\n    resolve<V>(resolver: (item: T) => V): Optional<V> {\n        if (this.isAbsent()) {\n            return Optional.absent;\n        }\n        try {\n            return Optional.fromNullable(resolver(this.value))\n        } catch (e) {\n            return Optional.absent;\n        }\n    }\n\n}\n\n// --------------------- From here onwards we break out the sideffects free limits ------------\n\n/**\n * ValueEmbedder is the writeable version\n * of optional, it basically is a wrappber\n * around a construct which has a state\n * and can be written to.\n *\n * For the readonly version see Optional\n */\nexport class ValueEmbedder<T> extends Optional<T> implements IValueHolder<T> {\n\n    /*default value for absent*/\n    static absent = ValueEmbedder.fromNullable(null);\n\n    protected key: string;\n\n    constructor(rootElem: any, valueKey: string = \"value\") {\n        super(rootElem);\n\n        this.key = valueKey;\n    }\n\n    get value(): T {\n        return this._value ? <T>this._value[this.key] : null;\n    }\n\n    set value(newVal: T) {\n        if (!this._value) {\n            return;\n        }\n        this._value[this.key] = newVal\n    }\n\n    orElse(elseValue: any): Optional<any> {\n        let alternative = {};\n        alternative[this.key] = elseValue;\n        return this.isPresent() ? this : new ValueEmbedder(alternative, this.key);\n    }\n\n    orElseLazy(func: () => any): Optional<any> {\n        if (this.isPresent()) {\n            return this;\n        } else {\n            let alternative = {};\n            alternative[this.key] = func();\n            return new ValueEmbedder(alternative, this.key);\n        }\n    }\n\n    /**\n     * helper to override several implementations in a more fluent way\n     * by having a getClass operation we can avoid direct calls into the constructor or\n     * static methods and do not have to implement several methods which rely on the type\n     * of \"this\"\n     * @returns {Monadish.Optional}\n     */\n    protected getClass(): any {\n        return ValueEmbedder;\n    }\n\n    static fromNullable<V extends Optional<T>,T>(value?: any, valueKey: string = \"value\"): V {\n        return <any> new ValueEmbedder<T>(value, valueKey);\n    }\n\n}\n\n/**\n * specialized value embedder\n * for our Configuration\n */\nclass ConfigEntry<T> extends ValueEmbedder<T> {\n\n    /*default value for absent*/\n    static absent = ConfigEntry.fromNullable(null);\n\n    /**\n     * arrayed value positions\n     */\n    arrPos: number;\n\n    constructor(rootElem: any, key: any, arrPos?: number) {\n        super(rootElem, key);\n\n        this.arrPos = arrPos ?? -1;\n    }\n\n    get value() {\n        if (this.key == \"\" && this.arrPos >= 0) {\n            return this._value[this.arrPos];\n        } else if (this.key && this.arrPos >= 0) {\n            return this._value[this.key][this.arrPos];\n        }\n        return this._value[this.key];\n    }\n\n    set value(val: T) {\n        if (this.key == \"\" && this.arrPos >= 0) {\n            this._value[this.arrPos] = val;\n            return;\n        } else if (this.key && this.arrPos >= 0) {\n            this._value[this.key][this.arrPos] = val;\n            return;\n        }\n        this._value[this.key] = val;\n    }\n}\n\n/**\n * Config, basically an optional wrapper for a json structure\n * (not sideeffect free, since we can alter the internal config state\n * without generating a new config), not sure if we should make it sideffect free\n * since this would swallow a lot of performane and ram\n */\nexport class Config extends Optional<any> {\n    constructor(root: any) {\n        super(root);\n    }\n\n    /**\n     * shallow copy getter, copies only the first level, references the deeper nodes\n     * in a shared manner\n     */\n    get shallowCopy(): Config {\n        return this.shallowCopy$();\n    }\n\n    protected shallowCopy$(): Config {\n        return new Config(Stream.ofAssoc(this.value).collect(new AssocArrayCollector()));\n    }\n\n    /**\n     * deep copy, copies all config nodes\n     */\n    get deepCopy(): Config {\n        return this.deepCopy$();\n    }\n\n    protected deepCopy$(): Config {\n        return new Config(objAssign({}, this.value));\n    }\n\n    /**\n     * creates a config from an initial value or null\n     * @param value\n     */\n    static fromNullable<T>(value?: T | null): Config {\n        return new Config(value);\n    }\n\n    /**\n     * simple merge for the root configs\n     */\n    shallowMerge(other: Config, overwrite = true, withAppend = false) {\n        for (let key in other.value) {\n            if (overwrite || !(key in this.value)) {\n                if (!withAppend) {\n                    this.assign(key).value = other.getIf(key).value;\n                } else {\n                    if (Array.isArray(other.getIf(key).value)) {\n                        Stream.of(...other.getIf(key).value).each(item => this.append(key).value = item);\n                    } else {\n                        this.append(key).value = other.getIf(key).value;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * assigns a single value as array, or appends it\n     * to an existing value mapping a single value to array\n     *\n     *\n     * usage myConfig.append(\"foobaz\").value = \"newValue\"\n     *       myConfig.append(\"foobaz\").value = \"newValue2\"\n     *\n     * resulting in myConfig.foobaz == [\"newValue, newValue2\"]\n     *\n     * @param {string[]} accessPath\n     */\n    append(...accessPath: string[]): IValueHolder<any> {\n        let noKeys = accessPath.length < 1;\n        if (noKeys) {\n            return;\n        }\n\n        let lastKey = accessPath[accessPath.length - 1];\n        let currKey, finalKey = this.keyVal(lastKey);\n\n        let pathExists = this.getIf(...accessPath).isPresent();\n        this.buildPath(accessPath);\n\n        let finalKeyArrPos = this.arrayIndex(lastKey);\n        if (finalKeyArrPos > -1) {\n            throw Error(\"Append only possible on non array properties, use assign on indexed data\");\n        }\n        let value = <any>this.getIf(...accessPath).value;\n        if (!Array.isArray(value)) {\n            value = this.assign(...accessPath).value = [value];\n        }\n        if (pathExists) {\n            value.push({});\n        }\n        finalKeyArrPos = value.length - 1;\n\n        let retVal = new ConfigEntry(accessPath.length == 1 ? this.value : this.getIf.apply(this, accessPath.slice(0, accessPath.length - 1)).value,\n            lastKey, finalKeyArrPos\n        );\n\n        return retVal;\n    }\n\n    /**\n     * appends to an existing entry (or extends into an array and appends)\n     * if the condition is met\n     * @param {boolean} condition\n     * @param {string[]} accessPath\n     */\n    appendIf(condition: boolean, ...accessPath: string[]): IValueHolder<any> {\n        if (!condition) {\n            return {value: null};\n        }\n        return this.append(...accessPath);\n    }\n\n    /**\n     * assings an new value on the given access path\n     * @param accessPath\n     */\n    assign(...accessPath): IValueHolder<any> {\n        if (accessPath.length < 1) {\n            return;\n        }\n\n        this.buildPath(accessPath);\n\n        let currKey = this.keyVal(accessPath[accessPath.length - 1]);\n        let arrPos = this.arrayIndex(accessPath[accessPath.length - 1]);\n        let retVal = new ConfigEntry(accessPath.length == 1 ? this.value : this.getIf.apply(this, accessPath.slice(0, accessPath.length - 1)).value,\n            currKey, arrPos\n        );\n\n        return retVal;\n    }\n\n    /**\n     * assign a value if the condition is set to true, otherwise skip it\n     *\n     * @param condition the condition, the access accessPath into the config\n     * @param accessPath\n     */\n    assignIf(condition: boolean, ...accessPath: Array<any>): IValueHolder<any> {\n        return condition ? this.assign(...accessPath) : {value: null};\n    }\n\n    /**\n     * get if the access path is present (get is reserved as getter with a default, on the current path)\n     * TODO will be renamed to something more meaningful and deprecated, the name is ambigous\n     * @param accessPath the access path\n     */\n    getIf(...accessPath: Array<string>): Config {\n        return this.getClass().fromNullable(super.getIf.apply(this, accessPath).value);\n    }\n\n\n\n    /**\n     * gets the current node and if none is present returns a config with a default value\n     * @param defaultVal\n     */\n    get(defaultVal: any): Config {\n        return this.getClass().fromNullable(super.get(defaultVal).value);\n    }\n\n    //empties the current config entry\n    delete(key: string): Config {\n        if (key in this.value) {\n            delete this.value[key];\n        }\n        return this;\n    }\n\n    /**\n     * converts the entire config into a json object\n     */\n    toJson(): any {\n        return JSON.stringify(this.value);\n    }\n\n    protected getClass(): any {\n        return Config;\n    }\n\n    private setVal(val: any) {\n        this._value = val;\n    }\n\n    /**\n     * builds the config path\n     *\n     * @param accessPath a sequential array of accessPath containing either a key name or an array reference name[<index>]\n     */\n    private buildPath(accessPath: Array<any>): Config {\n        let val = this;\n        let parentVal = this.getClass().fromNullable(null);\n        let parentPos = -1;\n        let alloc = function (arr: Array<any>, length: number) {\n            let length1 = arr.length;\n            let length2 = length1 + length;\n            for (let cnt = length1; cnt < length2; cnt++) {\n                arr.push({});\n            }\n        };\n\n        for (let cnt = 0; cnt < accessPath.length; cnt++) {\n            let currKey = this.keyVal(accessPath[cnt]);\n            let arrPos = this.arrayIndex(accessPath[cnt]);\n\n            if (currKey === \"\" && arrPos >= 0) {\n\n                val.setVal((val.value instanceof Array) ? val.value : []);\n                alloc(val.value, arrPos + 1);\n                if (parentPos >= 0) {\n                    parentVal.value[parentPos] = val.value;\n                }\n                parentVal = val;\n                parentPos = arrPos;\n                val = this.getClass().fromNullable(val.value[arrPos]);\n                continue;\n            }\n\n            let tempVal = <Config>val.getIf(currKey);\n            if (arrPos == -1) {\n                if (tempVal.isAbsent()) {\n                    tempVal = <Config>this.getClass().fromNullable(val.value[currKey] = {});\n                } else {\n                    val = <any>tempVal;\n                }\n            } else {\n                let arr = (tempVal.value instanceof Array) ? tempVal.value : [];\n                alloc(arr, arrPos + 1);\n                val.value[currKey] = arr;\n                tempVal = this.getClass().fromNullable(arr[arrPos]);\n            }\n            parentVal = val;\n            parentPos = arrPos;\n            val = <any>tempVal;\n        }\n\n        return this;\n    }\n}\n\n\n","/*!\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Stream, StreamMapper} from \"./Stream\";\nimport {DomQuery} from \"./DomQuery\";\nimport type = Mocha.utils.type;\n\n/**\n * special status of the datasource location pointer\n * if an access, outside of the possible data boundaries is happening\n * (example for instance current without a first next call, or next\n * which goes over the last possible dataset), an iteration status return\n * value is returned marking this boundary instead of a classical element\n *\n * Note this is only internally used but must be implemented to fullfill\n * internal contracts, the end user will never see those values if he uses\n * streams!\n */\nexport enum ITERATION_STATUS {\n    EO_STRM = '__EO_STRM__',\n    BEF_STRM = '___BEF_STRM__',\n}\n\n/**\n * Every data source wich feeds data into the lazy stream\n * or stream generally must implement this interface\n *\n * It is basically an iteratable to the core\n */\nexport interface IStreamDataSource<T> {\n\n    /**\n     * @returns true if additional data is present false if not\n     */\n    hasNext(): boolean;\n\n    /**\n     * returns the next element in the stream\n     */\n    next(): T | ITERATION_STATUS;\n\n    /**\n     * returns the next element in the stream\n     * difference to next is, that the internal data position\n     * is not changed, so next still will deliver the next item from the current\n     * data position. Look ahead is mostly needed internally\n     * by possible endless data constructs which have no fixed data boundary, or index\n     * positions. (aka infinite sets, or flatmapped constructs)\n     */\n    lookAhead(cnt ?: number): T | ITERATION_STATUS;\n\n    /**\n     * returns the current element, returns the same element as the previous next call\n     * if there is no next before current called then we will call next as initial element\n     */\n    current(): T | ITERATION_STATUS;\n\n    /**\n     * resets the position to the beginning\n     */\n    reset(): void;\n}\n\n/**\n * A collector, needs to be implemented\n */\nexport interface ICollector<T, S> {\n    /**\n     * this method basically takes a single stream element\n     * and does something with it (collecting it one way or the other\n     * in most cases)\n     *\n     * @param element\n     */\n    collect(element: T);\n\n    /**\n     * the final result after all the collecting is done\n     */\n    finalValue: S;\n}\n\n\n/**\n * defines a sequence of numbers for our stream input\n */\nexport class SequenceDataSource implements IStreamDataSource<number> {\n\n    start: number;\n    total: number;\n    value: number;\n\n    constructor(start: number, total: number) {\n        this.total = total;\n        this.start = start;\n        this.value = start - 1;\n    }\n\n\n    hasNext(): boolean {\n        return this.value < (this.total - 1);\n    }\n\n    next(): number | ITERATION_STATUS {\n        this.value++;\n        return this.value <= (this.total - 1) ? this.value : ITERATION_STATUS.EO_STRM;\n    }\n\n    lookAhead(cnt = 1): number | ITERATION_STATUS {\n        if((this.value + cnt) > this.total - 1) {\n            return ITERATION_STATUS.EO_STRM;\n        } else {\n            return this.value + cnt;\n        }\n    }\n\n    reset(): void {\n        this.value = this.start - 1;\n    }\n\n    current(): number | ITERATION_STATUS {\n        //first condition current without initial call for next\n        return (this.start - 1) ? ITERATION_STATUS.BEF_STRM : this.value;\n    }\n}\n\n\n/**\n * implementation of iteratable on top of array\n */\nexport class ArrayStreamDataSource<T> implements IStreamDataSource<T> {\n    value: Array<T>;\n    dataPos = -1;\n\n    constructor(...value: Array<T>) {\n        this.value = value;\n    }\n\n    lookAhead(cnt = 1): T |ITERATION_STATUS {\n        if((this.dataPos+cnt) > this.value.length - 1) {\n            return ITERATION_STATUS.EO_STRM;\n        }\n        return this.value[this.dataPos + cnt];\n    }\n\n    hasNext(): boolean {\n        return this.value.length - 1 > this.dataPos;\n    }\n\n    next(): T | ITERATION_STATUS {\n        this.dataPos++;\n        return this?.value[this.dataPos] ?? ITERATION_STATUS.EO_STRM;\n    }\n\n    reset() {\n        this.dataPos = -1;\n    }\n\n    current(): T {\n        return this.value[Math.max(0, this.dataPos)];\n    }\n}\n\n/**\n * an intermediate data source which prefilters\n * incoming stream data\n * and lets only the data out which\n * passes the filter function check\n */\nexport class FilteredStreamDatasource<T> implements IStreamDataSource<T> {\n\n    filterFunc: (T) => boolean;\n    inputDataSource: IStreamDataSource<T>;\n\n    _current: T | ITERATION_STATUS = ITERATION_STATUS.BEF_STRM;\n    // we have to add a filter idx because the external filter values might change over time, so\n    // we cannot reset the state properly unless we do it from a snapshot\n    _filterIdx = {};\n    _unfilteredPos = 0;\n\n    constructor(filterFunc: (T) => boolean, parent: IStreamDataSource<T>) {\n        this.filterFunc = filterFunc;\n        this.inputDataSource = parent;\n    }\n\n    /**\n     * in order to filter we have to make a look ahead until the\n     * first next allowed element\n     * hence we prefetch the element and then\n     * serve it via next\n     */\n    hasNext(): boolean {\n        let steps = 1;\n        let found = false;\n        let next;\n\n        while(!found && (next = this.inputDataSource.lookAhead(steps)) != ITERATION_STATUS.EO_STRM) {\n            if (this.filterFunc(next)) {\n                this._filterIdx[this._unfilteredPos + steps] = true;\n                found = true;\n            } else {\n                steps++;\n            }\n        }\n        return found;\n    }\n\n    /**\n     * serve the next element\n     */\n    next(): T | ITERATION_STATUS {\n        let found: T | ITERATION_STATUS = ITERATION_STATUS.EO_STRM;\n        while (this.inputDataSource.hasNext()) {\n            this._unfilteredPos ++;\n            let next: T = <T>this.inputDataSource.next();\n            //again here we cannot call the filter function twice, because its state might change, so if indexed, we have a decent snapshot, either has next or next can trigger\n            //the snapshot\n            if (next != ITERATION_STATUS.EO_STRM &&\n                ((this._filterIdx?.[this._unfilteredPos] ?? false) || this.filterFunc(next))) {\n                this._filterIdx[this._unfilteredPos] = true;\n                found = next;\n                break;\n            }\n        }\n        this._current = found as T;\n        return found;\n    }\n\n    lookAhead(cnt = 1): ITERATION_STATUS | T {\n        let lookupVal: T |ITERATION_STATUS;\n\n        for(let loop = 1; cnt > 0 && (lookupVal = this.inputDataSource.lookAhead(loop)) != ITERATION_STATUS.EO_STRM; loop++) {\n            let inCache = this._filterIdx?.[this._unfilteredPos + loop];\n            if(inCache || this.filterFunc(lookupVal)) {\n                cnt --;\n                this._filterIdx[this._unfilteredPos + loop] = true;\n            }\n        }\n        return lookupVal;\n    }\n\n    current(): T | ITERATION_STATUS {\n       return this._current;\n    }\n\n    reset(): void {\n        this._current = ITERATION_STATUS.BEF_STRM;\n        this._filterIdx = {};\n        this._unfilteredPos = 0;\n        this.inputDataSource.reset();\n    }\n}\n\n/**\n * an intermediate datasource which maps the items from\n * one into another\n */\nexport class MappedStreamDataSource<T, S> implements IStreamDataSource<S> {\n\n    mapFunc: (T) => S;\n    inputDataSource: IStreamDataSource<T>;\n\n    constructor(mapFunc: (T) => S, parent: IStreamDataSource<T>) {\n        this.mapFunc = mapFunc;\n        this.inputDataSource = parent;\n    }\n\n    hasNext(): boolean {\n        return this.inputDataSource.hasNext();\n    }\n\n    next(): S {\n        return this.mapFunc(this.inputDataSource.next());\n    }\n\n    reset(): void {\n        this.inputDataSource.reset();\n    }\n\n    current(): S {\n        return this.mapFunc(this.inputDataSource.current());\n    }\n\n    lookAhead(cnt= 1): ITERATION_STATUS | S {\n        const lookAheadVal = this.inputDataSource.lookAhead(cnt);\n        return (lookAheadVal == ITERATION_STATUS.EO_STRM) ? lookAheadVal as ITERATION_STATUS : this.mapFunc(lookAheadVal) as S;\n    }\n}\n\n/**\n * Same for flatmap to deal with element -> stream mappings\n */\nexport class FlatMapStreamDataSource<T, S> implements IStreamDataSource<S> {\n\n    mapFunc: StreamMapper<T>;\n\n    inputDataSource: IStreamDataSource<T>;\n\n    /**\n     * the currently active stream\n     * coming from an incoming element\n     * once the end of this one is reached\n     * it is swapped out by another one\n     * from the next element\n     */\n    activeDataSource: IStreamDataSource<S>;\n    walkedDataSources= [];\n    _currPos = 0;\n\n    constructor(func: StreamMapper<T>, parent: IStreamDataSource<T>) {\n        this.mapFunc = func;\n        this.inputDataSource = parent;\n    }\n\n    hasNext(): boolean {\n        return this.resolveActiveHasNext() || this.resolveNextHasNext();\n    }\n\n    private resolveActiveHasNext() {\n        let next = false;\n        if (this.activeDataSource) {\n            next = this.activeDataSource.hasNext();\n        }\n        return next;\n    }\n\n\n    lookAhead(cnt = 1): ITERATION_STATUS | S {\n        //easy access trial\n        if(this?.activeDataSource && this?.activeDataSource?.lookAhead(cnt) != ITERATION_STATUS.EO_STRM) {\n            //this should coverr 95% of all accesses\n            return this?.activeDataSource.lookAhead(cnt);\n        }\n\n        /**\n         * we only can determine how many elems datasource has by going up\n         * (for now this suffices, however not ideal, we might have to introduce a numElements or so)\n         * @param datasource\n         */\n        function howManyElems(datasource: IStreamDataSource<any>): number {\n            let cnt = 1;\n            while(datasource.lookAhead(cnt) !== ITERATION_STATUS.EO_STRM) {\n                cnt++;\n            }\n            return cnt - 1;\n        }\n        function readjustSkip(dataSource) {\n            let skippedElems = (dataSource) ? howManyElems(dataSource) : 0;\n            cnt = cnt - skippedElems;\n        }\n\n        if(this.activeDataSource) {\n            readjustSkip(this.activeDataSource)\n        }\n\n        //the idea is basically to look into the streams subsequentially for a match\n        //after each stream we have to take into consideration that the skipCnt is\n        //reduced by the number of datasets we already have looked into in the previous stream/datasource\n        //unfortunately for now we have to loop into them so we introduce a small o2 here\n        for(let dsLoop = 1; true ; dsLoop++) {\n            let currDatasource = this.inputDataSource.lookAhead(dsLoop);\n            //we have looped out\n            if(currDatasource === ITERATION_STATUS.EO_STRM) {\n                return ITERATION_STATUS.EO_STRM;\n            }\n            let mapped = this.mapFunc(currDatasource as T);\n            //it either comes in as datasource or as array\n            let currentDataSource = this.toDatasource(mapped);\n            let ret = currentDataSource.lookAhead(cnt);\n            if(ret != ITERATION_STATUS.EO_STRM) {\n                return ret;\n            }\n            readjustSkip(currDatasource);\n\n        }\n    }\n\n    private toDatasource(mapped: Array<S> | IStreamDataSource<S>) {\n        let ds = Array.isArray(mapped) ? new ArrayStreamDataSource(...mapped) : mapped;\n        this.walkedDataSources.push(ds)\n        return ds;\n    }\n\n    private resolveNextHasNext() {\n        let next = false;\n        while (!next && this.inputDataSource.hasNext()) {\n            let mapped = this.mapFunc(this.inputDataSource.next() as T);\n            this.activeDataSource = this.toDatasource(mapped);;\n            next = this.activeDataSource.hasNext();\n        }\n        return next;\n    }\n\n    next(): S | ITERATION_STATUS {\n        if(this.hasNext()) {\n            this._currPos++;\n            return this.activeDataSource.next();\n        }\n    }\n\n    reset(): void {\n        this.inputDataSource.reset();\n        this.walkedDataSources.forEach(ds => ds.reset());\n        this.walkedDataSources = [];\n        this._currPos = 0;\n        this.activeDataSource = null;\n    }\n\n    current(): S | ITERATION_STATUS{\n        if(!this.activeDataSource) {\n            this.hasNext();\n        }\n        return this.activeDataSource.current();\n    }\n}\n\n/**\n * For the time being we only need one collector\n * a collector which collects a stream back into arrays\n */\nexport class ArrayCollector<S> implements ICollector<S, Array<S>> {\n    private data: Array<S> = [];\n\n    collect(element: S) {\n        this.data.push(element);\n    }\n\n    get finalValue(): Array<S> {\n        return this.data;\n    }\n}\n\n/**\n * collects an tuple array stream into an assoc array with elements being collected into arrays\n *\n */\nexport class ArrayAssocArrayCollector<S> implements ICollector<[string, S] | string, {[key: string]: S} > {\n    finalValue: {[key:string]: any} = {};\n\n    collect(element: [string, S] | string) {\n        let key = element?.[0] ?? <string> element;\n        this.finalValue[key] = this.finalValue?.[key] ?? [];\n        this.finalValue[key].push(element?.[1] ?? true);\n    }\n}\n\n/**\n * dummy collector which just triggers a run\n * on lazy streams without collecting anything\n */\nexport class Run<S> implements ICollector<S, any> {\n    collect(element: S) {\n\n    }\n\n    get finalValue(): any {\n        return null;\n    }\n}\n\n/**\n * collects an assoc stream back to an assoc array\n */\nexport class AssocArrayCollector<S> implements ICollector<[string, S] | string, { [key: string]: S }> {\n\n    finalValue: { [key: string]: any } = {};\n\n    collect(element: [string, S] | string) {\n        this.finalValue[element[0] ?? <string>element] = element[1] ?? true;\n    }\n}\n\n/**\n * Form data collector for key value pair streams\n */\nexport class FormDataCollector implements ICollector<{ key: string, value: any }, FormData> {\n    finalValue: FormData = new FormData();\n\n    collect(element: { key: string; value: any }) {\n        this.finalValue.append(element.key, element.value);\n    }\n}\n\n/**\n * Form data collector for DomQuery streams\n */\nexport class QueryFormDataCollector implements ICollector<DomQuery, FormData> {\n    finalValue: FormData = new FormData();\n\n    collect(element: DomQuery) {\n        let toMerge = element.encodeFormElement();\n        if (toMerge.isPresent()) {\n            this.finalValue.append(element.name.value, toMerge.get(element.name).value);\n        }\n    }\n}\n\n/**\n * Encoded String collector from dom query streams\n */\nexport class QueryFormStringCollector implements ICollector<DomQuery, string> {\n\n    formData: [[string, string]] = <any>[];\n\n    collect(element: DomQuery) {\n        let toMerge = element.encodeFormElement();\n        if (toMerge.isPresent()) {\n            this.formData.push([element.name.value, toMerge.get(element.name).value]);\n        }\n    }\n\n    get finalValue(): string {\n        return Stream.of(...this.formData)\n            .map<string>(keyVal => keyVal.join(\"=\"))\n            .reduce((item1, item2) => [item1, item2].join(\"&\"))\n            .orElse(\"\").value;\n    }\n}","/*!\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * A small stream implementation\n */\nimport {IMonad, IValueHolder, Optional} from \"./Monad\";\nimport {\n    ArrayCollector,\n    ArrayStreamDataSource,\n    FilteredStreamDatasource,\n    FlatMapStreamDataSource,\n    ICollector,\n    IStreamDataSource,\n    ITERATION_STATUS,\n    MappedStreamDataSource\n} from \"./SourcesCollectors\";\n//import {from, Observable} from \"rxjs\";\n\n\n/*\n * some typedefs to make the code more reabable\n */\nexport type StreamMapper<T> = (data: T) => IStreamDataSource<any>;\nexport type ArrayMapper<T> = (data: T) => Array<any>;\nexport type IteratableConsumer<T> = (data: T, pos ?: number) => void | boolean;\nexport type Reducable<T, V> = (val1: T | V, val2: T) => V;\nexport type Matchable<T> = (data: T) => boolean;\nexport type Mappable<T, R> = (data: T) => R;\nexport type Comparator<T> = (el1: T, el2: T) => number;\n\n/**\n * Generic interface defining a stream\n */\nexport interface IStream<T> {\n    /**\n     * Perform the operation fn on a single element in the stream at a time\n     * then pass the stream over for further processing\n     * This is basically an intermediate point in the stream\n     * with further processing happening later, do not use\n     * this method to gather data or iterate over all date for processing\n     * (for the second case each has to be used)\n     *\n     * @param fn the processing function, if it returns false, further processing is stopped\n     */\n    onElem(fn: IteratableConsumer<T>): IStream<T>;\n\n    /**\n     * Iterate over all elements in the stream and do some processing via fn\n     *\n     * @param fn takes a single element and if it returns false\n     * then further processing is stopped\n     */\n    each(fn: IteratableConsumer<T>): void;\n\n\n    /**\n     * maps a single element into another via fn\n     * @param fn function which takes one element in and returns another\n     */\n    map<R>(fn?: Mappable<T, R>): IStream<R>;\n\n    /**\n     * Takes an element in and returns a set of something\n     * the set then is flatted into a single stream to be further processed\n     *\n     * @param fn\n     */\n    flatMap<R>(fn?: StreamMapper<T> | ArrayMapper<T>): IStream<R>;\n\n    /**\n     * filtering, takes an element in and is processed by fn.\n     * If it returns false then further processing on this element is skipped\n     * if it returns true it is passed down the chain.\n     *\n     * @param fn\n     */\n    filter(fn?: Matchable<T>): IStream<T>;\n\n    /**\n     * functional reduce... takes two elements in the stream and reduces to\n     * one from left to right\n     *\n     * @param fn the reduction function for instance (val1,val2) => val1l+val2\n     * @param startVal an optional starting value, if provided the the processing starts with this element\n     * and further goes down into the stream, if not, then the first two elements are taken as reduction starting point\n     */\n    reduce<V>(fn: Reducable<T, V>, startVal: T | V): Optional<T | V>;\n\n    /**\n     * returns the first element in the stream is given as Optional\n     */\n    first(): Optional<T>;\n\n    /**\n     * Returns the last stream element (note in endless streams without filtering and limiting you will never reach that\n     * point hence producing an endless loop)\n     */\n    last(): Optional<T>;\n\n    /**\n     * returns true if there is at least one element where a call fn(element) produces true\n     *\n     * @param fn\n     */\n    anyMatch(fn: Matchable<T>): boolean;\n\n    /**\n     * returns true if all elmements produce true on a call to fn(element)\n     *\n     * @param fn\n     */\n    allMatch(fn: Matchable<T>): boolean;\n\n    /**\n     * returns true if no elmements produce true on a call to fn(element)\n     *\n     * @param fn\n     */\n    noneMatch(fn: Matchable<T>): boolean;\n\n    /**\n     * Collect the elements with a collector given\n     * There are a number of collectors provided\n     *\n     * @param collector\n     */\n    collect(collector: ICollector<T, any>): any;\n\n    /**\n     * sort on the stream, this is a special case\n     * of an endpoint, so your data which is fed in needs\n     * to be limited otherwise it will fail\n     * it still returns a stream for further processing\n     *\n     * @param comparator\n     */\n    sort(comparator: Comparator<T>): IStream<T>;\n\n    /**\n     * Limits the stream to a certain number of elements\n     *\n     * @param end the limit of the stream\n     */\n    limits(end: number): IStream<T>;\n\n\n    concat(...toAppend: Array<IStream<T>>): IStream<T>\n\n    /**\n     * returns the stream collected into an array (90% use-case abbreviation\n     */\n    value: Array<T>;\n\n    /**\n     * returns an observable of the given stream\n     */\n    [Symbol.iterator](): Iterator<T>;\n\n    //observable: Observable<T>;\n}\n\n/**\n * A simple typescript based reimplementation of streams\n *\n * This is the early eval version\n * for a lazy eval version check, LazyStream, which is api compatible\n * to this implementation, however with the benefit of being able\n * to provide infinite data sources and generic data providers, the downside\n * is, it might be a tad slower in some situations\n */\nexport class Stream<T> implements IMonad<T, Stream<any>>, IValueHolder<Array<T>>, IStream<T> {\n\n    value: Array<T>;\n    _limits = -1;\n\n    private pos = -1;\n\n    constructor(...value: T[]) {\n        this.value = value;\n    }\n\n    static of<T>(...data: Array<T>): Stream<T> {\n        return new Stream<T>(...data);\n    }\n\n    static ofAssoc<T>(data: { [key: string]: T }): Stream<[string, T]> {\n        return this.of(...Object.keys(data)).map(key => [key, data[key]]);\n    }\n\n    static ofDataSource<T>(dataSource: IStreamDataSource<T>) {\n        let value: T[] = [];\n        while (dataSource.hasNext()) {\n            value.push(dataSource.next() as T);\n        }\n\n        return new Stream(...value);\n    }\n\n    limits(end: number): Stream<T> {\n        this._limits = end;\n        return this;\n    }\n\n    /**\n     * concat for streams, so that you can concat two streams together\n     * @param toAppend\n     */\n    concat(...toAppend: Array<IStream<T>>): Stream<T> {\n        //let dataSource = new MultiStreamDatasource<T>(this, ...toAppend);\n        //return Stream.ofDataSource<T>(dataSource);\n\n        return Stream.of(<IStream<T>>this, ...toAppend).flatMap(item => item);\n    }\n\n\n    onElem(fn: (data: T, pos ?: number) => void | boolean): Stream<T> {\n        for (let cnt = 0; cnt < this.value.length && (this._limits == -1 || cnt < this._limits); cnt++) {\n            if (fn(this.value[cnt], cnt) === false) {\n                break;\n            }\n        }\n        return this;\n    }\n\n\n    each(fn: (data: T, pos ?: number) => void | boolean) {\n        this.onElem(fn);\n        this.reset();\n    }\n\n    map<R>(fn?: (data: T) => R): Stream<R> {\n        if (!fn) {\n            fn = (inval: any) => <R>inval;\n        }\n        let res: R[] = [];\n        this.each((item) => {\n            res.push(fn(item))\n        });\n\n        return new Stream<R>(...res);\n    }\n\n    /*\n     * we need to implement it to fullfill the contract, although it is used only internally\n     * all values are flattened when accessed anyway, so there is no need to call this methiod\n     */\n\n    flatMap<IStreamDataSource>(fn: (data: T) => IStreamDataSource | Array<any>): Stream<any> {\n        let ret = [];\n        this.each(item => {\n            let strmR: any = fn(item);\n            ret = Array.isArray(strmR) ? ret.concat(strmR) : ret.concat(...strmR.value);\n        });\n        return <Stream<any>>Stream.of(...ret);\n    }\n\n    filter(fn?: (data: T) => boolean): Stream<T> {\n        let res: Array<T> = [];\n        this.each((data) => {\n            if (fn(data)) {\n                res.push(data);\n            }\n        });\n        return new Stream<T>(...res);\n    }\n\n    reduce<V>(fn: Reducable<T, V | T>, startVal: V = null): Optional<V | T> {\n        let offset = startVal != null ? 0 : 1;\n        let val1: V | T = startVal != null ? startVal : this.value.length ? this.value[0] : null;\n\n        for (let cnt = offset; cnt < this.value.length && (this._limits == -1 || cnt < this._limits); cnt++) {\n            val1 = fn(val1, this.value[cnt]);\n        }\n        this.reset();\n        return Optional.fromNullable<Optional<any>, V | T>(val1);\n    }\n\n    first(): Optional<T> {\n        this.reset();\n        return this.value && this.value.length ? Optional.fromNullable(this.value[0]) : Optional.absent;\n    }\n\n    last(): Optional<T> {\n        //could be done via reduce, but is faster this way\n        let length = this._limits > 0 ? Math.min(this._limits, this.value.length) : this.value.length;\n        this.reset();\n        return Optional.fromNullable(length ? this.value[length - 1] : null);\n    }\n\n    anyMatch(fn: Matchable<T>): boolean {\n        for (let cnt = 0; cnt < this.value.length && (this._limits == -1 || cnt < this._limits); cnt++) {\n            if (fn(this.value[cnt])) {\n                return true;\n            }\n        }\n        this.reset();\n        return false;\n    }\n\n    allMatch(fn: Matchable<T>): boolean {\n        if (!this.value.length) {\n            return false;\n        }\n        let matches = 0;\n        for (let cnt = 0; cnt < this.value.length; cnt++) {\n            if (fn(this.value[cnt])) {\n                matches++;\n            }\n        }\n        this.reset();\n        return matches == this.value.length;\n    }\n\n    noneMatch(fn: Matchable<T>): boolean {\n        let matches = 0;\n        for (let cnt = 0; cnt < this.value.length; cnt++) {\n            if (!fn(this.value[cnt])) {\n                matches++;\n            }\n        }\n        this.reset();\n        return matches == this.value.length;\n    }\n\n    sort(comparator: Comparator<T>): IStream<T> {\n        let newArr = this.value.slice().sort(comparator);\n        return Stream.of(...newArr);\n    }\n\n\n    collect(collector: ICollector<T, any>): any {\n        this.each(data => collector.collect(data));\n        this.reset();\n        return collector.finalValue;\n    }\n\n    //-- internally exposed methods needed for the interconnectivity\n    hasNext(): boolean {\n        let isLimitsReached = this._limits != -1 && this.pos >= this._limits - 1;\n        let isEndOfArray = this.pos >= this.value.length - 1;\n        return !(isLimitsReached || isEndOfArray);\n    }\n\n    next(): T {\n        if (!this.hasNext()) {\n            return null;\n        }\n        this.pos++;\n        return this.value[this.pos];\n    }\n\n    lookAhead(cnt = 1): T | ITERATION_STATUS {\n        if((this.pos + cnt) >= this.value.length) {\n            return ITERATION_STATUS.EO_STRM;\n        }\n        return this.value[this.pos + cnt];\n    }\n\n\n    [Symbol.iterator]() : Iterator<T> {\n        return {\n            next: () => {\n                let done = !this.hasNext();\n                let val = this.next();\n                return {\n                    done: done,\n                    value: <T>val\n                }\n            }\n        }\n    }\n\n    /*get observable(): Observable<T> {\n        return from(this);\n    }*/\n\n    reset() {\n        this.pos = -1;\n    }\n}\n\n/**\n * Lazy implementation of a Stream\n * The idea is to connect the intermediate\n * streams as datasources like a linked list\n * with reverse referencing and for special\n * operations like filtering flatmapping\n * have intermediate datasources in the list\n * with specialized functions.\n *\n * Sort of a modified pipe valve pattern\n * the streams are the pipes the intermediate\n * data sources are the valves\n *\n * We then can use passed in functions to control\n * the flow in the valves\n *\n * That way we can have a lazy evaluating stream\n *\n * So if an endpoint requests data\n * a callback trace goes back the stream list\n * which triggers an operation upwards\n * which sends data down the drain which then is processed\n * and filtered until one element hits the endpoint.\n *\n * That is repeated, until all elements are processed\n * or an internal limit is hit.\n *\n */\nexport class LazyStream<T> implements IStreamDataSource<T>, IStream<T>, IMonad<T, LazyStream<any>> {\n\n    protected dataSource: IStreamDataSource<T>;\n    _limits = -1;\n\n    /*\n     * needed to have the limits check working\n     * we need to keep track of the current position\n     * in the stream\n     */\n    pos = -1;\n\n    static of<T>(...values: Array<T>): LazyStream<T> {\n        return new LazyStream<T>(new ArrayStreamDataSource(...values));\n    }\n\n    static ofAssoc<T>(data: { [key: string]: T }): LazyStream<[string, T]> {\n        return this.of(...Object.keys(data)).map(key => [key, data[key]]);\n    }\n\n    static ofStreamDataSource<T>(value: IStreamDataSource<T>): LazyStream<T> {\n        return new LazyStream(value);\n    }\n\n    constructor(parent: IStreamDataSource<T>) {\n        this.dataSource = parent;\n\n    }\n\n    hasNext(): boolean {\n        if (this.isOverLimits()) {\n            return false;\n        }\n\n        return this.dataSource.hasNext();\n    }\n\n    next(): T | ITERATION_STATUS {\n        let next = this.dataSource.next();\n        // @ts-ignore\n        this.pos++;\n        return next;\n    }\n\n    lookAhead(cnt= 1): ITERATION_STATUS | T {\n        return this.dataSource.lookAhead(cnt);\n    }\n\n\n\n    current(): T | ITERATION_STATUS {\n        return this.dataSource.current();\n    }\n\n    reset(): void {\n        this.dataSource.reset();\n        this.pos = -1;\n        this._limits = -1;\n    }\n\n    /**\n     * concat for streams, so that you can concat two streams together\n     * @param toAppend\n     */\n    concat(...toAppend: Array<IStream<T>>): LazyStream<T> {\n        //this.dataSource =  new MultiStreamDatasource<T>(this, ... toAppend);\n        //return this;\n        return LazyStream.of(<IStream<T>>this, ...toAppend).flatMap(item => item);\n    }\n\n    nextFilter(fn: Matchable<T>): T {\n        if (this.hasNext()) {\n            let newVal: T = this.next() as T;\n            if (!fn(newVal)) {\n                return this.nextFilter(fn);\n            }\n            return <T>newVal;\n        }\n        return null;\n    }\n\n    limits(max: number): LazyStream<T> {\n        this._limits = max;\n        return this;\n    }\n\n    //main stream methods\n    collect(collector: ICollector<T, any>): any {\n        while (this.hasNext()) {\n            let t = this.next();\n            collector.collect(<T>t);\n        }\n        this.reset();\n        return collector.finalValue;\n    }\n\n    onElem(fn: IteratableConsumer<T>): LazyStream<T> {\n        return new LazyStream(new MappedStreamDataSource((el) => {\n            if (fn(el, this.pos) === false) {\n                this.stop();\n            }\n            return el;\n        }, this));\n    }\n\n    filter(fn: Matchable<T>): LazyStream<T> {\n        return <LazyStream<T>>new LazyStream<T>(new FilteredStreamDatasource<any>(fn, this));\n    }\n\n    map<R>(fn: Mappable<T, R>): LazyStream<any> {\n        return new LazyStream(new MappedStreamDataSource(fn, this));\n    }\n\n    flatMap<StreamMapper>(fn: StreamMapper | ArrayMapper<any>): LazyStream<any> {\n        return new LazyStream<any>(new FlatMapStreamDataSource(<any>fn, this));\n    }\n\n    //endpoint\n    each(fn: IteratableConsumer<T>) {\n        while (this.hasNext()) {\n            if (fn(this.next() as T) === false) {\n                this.stop();\n            }\n        }\n        this.reset();\n    }\n\n    reduce<V>(fn: Reducable<T, V>, startVal: T | V = null): Optional<T | V> {\n        if (!this.hasNext()) {\n            return Optional.absent;\n        }\n        let value1;\n        let value2 = null;\n        if (startVal != null) {\n            value1 = startVal;\n            value2 = this.next();\n        } else {\n            value1 = this.next();\n            if (!this.hasNext()) {\n                return Optional.fromNullable(value1);\n            }\n            value2 = this.next();\n        }\n        value1 = fn(value1, value2);\n        while (this.hasNext()) {\n            value2 = this.next();\n            value1 = fn(value1, value2);\n        }\n        this.reset();\n        return Optional.fromNullable(value1);\n    }\n\n    last(): Optional<T> {\n        if (!this.hasNext()) {\n            return Optional.absent;\n        }\n        return this.reduce((el1, el2) => el2);\n    }\n\n    first(): Optional<T> {\n        this.reset();\n        if (!this.hasNext()) {\n            return Optional.absent;\n        }\n        return Optional.fromNullable(this.next() as T);\n    }\n\n    anyMatch(fn: Matchable<T>): boolean {\n        while (this.hasNext()) {\n            if (fn(this.next() as T)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    allMatch(fn: Matchable<T>): boolean {\n        while (this.hasNext()) {\n            if (!fn(this.next() as T)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    noneMatch(fn: Matchable<T>): boolean {\n        while (this.hasNext()) {\n            if (fn(this.next() as T)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    sort(comparator: Comparator<T>): IStream<T> {\n        let arr = this.collect(new ArrayCollector());\n        arr = arr.sort(comparator);\n        return LazyStream.of(...arr);\n    }\n\n    get value(): Array<T> {\n        return this.collect(new ArrayCollector<T>());\n    }\n\n    [Symbol.iterator]() : Iterator<T> {\n        return {\n            next: () => {\n                let done = !this.hasNext();\n                let val = this.next();\n                return {\n                    done: done,\n                    value: <T>val\n                }\n            }\n        }\n    }\n\n    /*get observable(): Observable<T> {\n        return from(this);\n    }*/\n\n    private stop() {\n        this.pos = this._limits + 1000000000;\n        this._limits = 0;\n    }\n\n    private isOverLimits() {\n        return this._limits != -1 && this.pos >= this._limits - 1;\n    }\n\n}\n\n\n","/*!\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Lang} from \"./Lang\";\nimport {DomQuery} from \"./DomQuery\";\nimport isString = Lang.isString;\nimport {_global$} from \"./Global\";\n\ndeclare let ActiveXObject: any;\n\n/**\n * xml query as specialized case for DomQuery\n */\nexport class XMLQuery extends DomQuery {\n\n    constructor(rootNode: Document | string | DomQuery, docType: string = \"text/xml\") {\n\n        let createIe11DomQueryShim = (): DOMParser => {\n            //at the time if wroting ie11 is the only relevant browser\n            //left withut any DomQuery support\n            let parser = new ActiveXObject(\"Microsoft.XMLDOM\");\n            parser.async = false;\n            //we shim th dom parser from ie in\n            return <any>{\n                parseFromString: (text: string, contentType: string): Document => {\n                    return parser.loadXML(text);\n                }\n            }\n        };\n\n        let parseXML = (xml: string): Document => {\n            if (xml == null) {\n                return null;\n            }\n            let domParser: DOMParser = Lang.saveResolveLazy<DOMParser>(\n                () => new (_global$()).DOMParser(),\n                (): DOMParser => createIe11DomQueryShim()\n            ).value;\n            return domParser.parseFromString(xml, <any> docType);\n        };\n\n        if (isString(rootNode)) {\n            super(parseXML(<string>rootNode))\n        } else {\n            super(rootNode);\n        }\n    }\n\n    isXMLParserError(): boolean {\n        return this.querySelectorAll(\"parsererror\").isPresent();\n    }\n\n    toString(): string {\n        let ret = [];\n        this.eachElem((node: any) => {\n            let serialized = (_global$())?.XMLSerializer?.constructor()?.serializeToString(node) ?? node?.xml;\n            if (!!serialized) {\n                ret.push(serialized);\n            }\n        });\n        return ret.join(\"\");\n    }\n\n    parserErrorText(joinstr: string): string {\n        return this.querySelectorAll(\"parsererror\").textContent(joinstr);\n    }\n\n    static parseXML(txt: string): XMLQuery {\n        return new XMLQuery(txt);\n    }\n\n    static parseHTML(txt: string): XMLQuery {\n        return new XMLQuery(txt, \"text/html\");\n    }\n\n    static fromString(txt: string, parseType: string = \"text/xml\"): XMLQuery {\n        return new XMLQuery(txt, parseType);\n    }\n}\n\nexport const XQ = XMLQuery;\nexport type XQ = XMLQuery;","/*!\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nexport {DomQuery, ElementAttribute, DomQueryCollector, DQ, DQ$} from \"./DomQuery\";\nexport {Lang} from \"./Lang\";\nexport {Config, Monad, IValueHolder, IFunctor, IMonad, IIdentity, Optional, ValueEmbedder} from \"./Monad\";\nexport {XMLQuery, XQ} from \"./XmlQuery\";\nexport {Stream, LazyStream, IteratableConsumer, IStream} from \"./Stream\";\nexport {\n    ArrayStreamDataSource,\n    MappedStreamDataSource,\n    FilteredStreamDatasource,\n    FlatMapStreamDataSource,\n    SequenceDataSource,\n    QueryFormStringCollector,\n    IStreamDataSource,\n    ICollector,\n    ArrayCollector,\n    AssocArrayCollector,\n    FormDataCollector,\n    QueryFormDataCollector\n} from \"./SourcesCollectors\";\n\n\n\n\n\n\n","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Implementation} from \"../impl/AjaxImpl\";\nimport {PushImpl} from \"../impl/PushImpl\";\nimport {oam as _oam} from \"../myfaces/OamSubmit\";\nimport {$nsp, CTX_PARAM_EXECUTE, CTX_PARAM_RENDER, P_BEHAVIOR_EVENT} from \"../impl/core/Const\";\nimport {ErrorData} from \"../impl/xhrCore/ErrorData\";\nimport {EventData} from \"../impl/xhrCore/EventData\";\n\n//we use modules to get a proper jsdoc and static/map structure in the calls\n//as per spec requirement\nexport module faces {\n\n\n    /**\n     * Version of the implementation for the faces.ts.\n     * <p />\n     * as specified within the jsf specifications faces.html:\n     * <ul>\n     * <li>left two digits major release number</li>\n     * <li>middle two digits minor spec release number</li>\n     * <li>right two digits bug release number</li>\n     * </ul>\n     * @constant\n     */\n    export var specversion = 400000;\n    /**\n     * Implementation version as specified within the jsf specification.\n     * <p />\n     * A number increased with every implementation version\n     * and reset by moving to a new spec release number\n     *\n     * @constant\n     */\n    export var implversion = 0;\n\n    /**\n     * SeparatorChar as defined by facesContext.getNamingContainerSeparatorChar()\n     * @type {Char}\n     */\n    export var separatorchar = getSeparatorChar();\n\n    /**\n     * Context Path as defined externalContext.requestContextPath\n     */\n    export var contextpath = '#{facesContext.externalContext.requestContextPath}';\n    // we do not have a fallback here, for now\n\n    /**\n     * This method is responsible for the return of a given project stage as defined\n     * by the jsf specification.\n     * <p/>\n     * Valid return values are:\n     * <ul>\n     *     <li>&quot;Production&quot;</li>\n     *     <li>&quot;Development&quot;</li>\n     *     <li>&quot;SystemTest&quot;</li>\n     *     <li>&quot;UnitTest&quot;</li>\n     * </li>\n     *\n     * @return {String} the current project state emitted by the server side method:\n     * <i>jakarta.faces.application.Application.getProjectStage()</i>\n     */\n    export function getProjectStage(): string {\n        return Implementation.getProjectStage();\n    }\n\n    /**\n     * collect and encode data for a given form element (must be of type form)\n     * find the jakarta.faces.ViewState element and encode its value as well!\n     * return a concatenated string of the encoded values!\n     *\n     * @throws an exception in case of the given element not being of type form!\n     * https://issues.apache.org/jira/browse/MYFACES-2110\n     */\n    export function getViewState(formElement: Element | string): string {\n        return Implementation.getViewState(formElement);\n    }\n\n    /**\n     * returns the window identifier for the given node / window\n     * @return the window identifier or null if none is found\n     * @param rootNode\n     */\n    export function getClientWindow(rootNode?: Element | string): string {\n        return Implementation.getClientWindow(rootNode);\n    }\n\n    //private helper functions\n    function getSeparatorChar(): string {\n        const sep = '#{facesContext.namingContainerSeparatorChar}';\n        //We now enable standalone mode, the separator char was not mapped we make a fallback to 2.3 behavior\n        //the idea is that the separator char is provided from the underlying container, but if not then we\n        //will perform a fallback (aka 2.3 has the url fallback behavior)\n        return (sep.match(/\\#\\{facesContext.namingContainerSeparatorChar\\}/gi)) ? Implementation.getSeparatorChar() : sep;\n    }\n\n\n\n\n    export module ajax {\n        \"use strict\";\n\n        /**\n         * this function has to send the ajax requests\n         *\n         * following requestInternal conditions must be met:\n         * <ul>\n         *  <li> the requestInternal must be sent asynchronously! </li>\n         *  <li> the requestInternal must be a POST!!! requestInternal </li>\n         *  <li> the requestInternal url must be the form action attribute </li>\n         *  <li> all requests must be queued with a client side requestInternal queue to ensure the requestInternal ordering!</li>\n         * </ul>\n         *\n         * @param {String|Node} element: any dom element no matter being it html or jsf, from which the event is emitted\n         * @param {EVENT} event: any javascript event supported by that object\n         * @param {Map} options : map of options being pushed into the ajax cycle\n         */\n        export function request(element: Element, event?: Event, options?: Context): void {\n            Implementation.request(element, event, options)\n        }\n\n        /**\n         * response handler\n         * @param request the request object having triggered this response\n         * @param context the request context\n         *\n         * TODO add info on what can be in the context\n         */\n        export function response(request: XMLHttpRequest, context?: Context): void {\n            Implementation.response(request, context);\n        }\n\n        /**\n         * Adds an error handler to our global error queue.\n         * the error handler must be of the format <i>function errorListener(&lt;errorData&gt;)</i>\n         * with errorData being of following format:\n         * <ul>\n         *     <li> errorData.type : &quot;error&quot;</li>\n         *     <li> errorData.status : the error status message</li>\n         *     <li> errorData.serverErrorName : the server error name in case of a server error</li>\n         *     <li> errorData.serverErrorMessage : the server error message in case of a server error</li>\n         *     <li> errorData.source  : the issuing source element which triggered the requestInternal </li>\n         *     <li> eventData.responseCode: the response code (aka http requestInternal response code, 401 etc...) </li>\n         *     <li> eventData.responseText: the requestInternal response text </li>\n         *     <li> eventData.responseXML: the requestInternal response xml </li>\n         * </ul>\n         *\n         * @param {function} errorListener error handler must be of the format <i>function errorListener(&lt;errorData&gt;)</i>\n         */\n        export function addOnError(errorFunc: (data: ErrorData) => void): void {\n            Implementation.addOnError(<any>errorFunc);\n        }\n\n        /**\n         * Adds a global event listener to the ajax event queue. The event listener must be a function\n         * of following format: <i>function eventListener(&lt;eventData&gt;)</i>\n         *\n         * @param {function} eventListener event must be of the format <i>function eventListener(&lt;eventData&gt;)</i>\n         */\n        export function addOnEvent(eventFunc: (data: EventData) => void): void {\n            Implementation.addOnEvent(<any>eventFunc);\n        }\n    }\n\n    export module util {\n\n        /**\n         * varargs function which executes a chain of code (functions or any other code)\n         *\n         * if any of the code returns false, the execution\n         * is terminated prematurely skipping the rest of the code!\n         *\n         * @param {DomNode} source, the callee object\n         * @param {Event} event, the event object of the callee event triggering this function\n         * @param funcs ... arbitrary array of functions or strings\n         * @returns true if the chain has succeeded false otherwise\n         */\n        export function chain(source, event, ...funcs: Array<Function | string>): boolean {\n            return Implementation.chain(source, event, ...(funcs as EvalFuncs));\n        }\n    }\n\n    export module push {\n        /**\n         * @param {function} onopen The function to be invoked when the web socket is opened.\n         * @param {function} onmessage The function to be invoked when a message is received.\n         * @param {function} onclose The function to be invoked when the web socket is closed.\n         * @param {boolean} autoconnect Whether or not to immediately open the socket. Defaults to <code>false</code>.\n         */\n        export function init(socketClientId: string,\n                    uri: string,\n                    channel: string,\n                    onopen: Function,\n                    onmessage: Function,\n                    onclose: Function,\n                    behaviorScripts: any,\n                    autoconnect: boolean): void {\n            PushImpl.init(socketClientId, uri, channel, onopen, onmessage, onclose, behaviorScripts, autoconnect);\n        }\n\n        /**\n         * Open the web socket on the given channel.\n         * @param {string} channel The name of the web socket channel.\n         * @throws {Error} When channel is unknown.\n         */\n        export function open(socketClientId: string): void {\n            PushImpl.open(socketClientId);\n        }\n\n        /**\n         * Close the web socket on the given channel.\n         * @param {string} channel The name of the web socket channel.\n         * @throws {Error} When channel is unknown.\n         */\n        export function close(socketClientId: string): void {\n            PushImpl.close(socketClientId);\n        }\n\n    }\n}\n\nexport module myfaces {\n    /**\n     * AB function similar to mojarra and Primefaces\n     * not part of the spec but a convenience accessor method\n     * Code provided by Thomas Andraschko\n     *\n     * @param source the event source\n     * @param event the event\n     * @param eventName event name for java.jakarta.faces.behavior.evemnt\n     * @param execute execute list as passed down in faces.ajax.request\n     * @param render\n     * @param options\n     */\n    export function ab(source: Element, event: Event, eventName: string, execute: string, render: string, options: Context = {}): void {\n        if (eventName) {\n           options[$nsp(P_BEHAVIOR_EVENT)] = eventName;\n        }\n        if (execute) {\n            options[CTX_PARAM_EXECUTE] = execute;\n        }\n        if (render) {\n            options[CTX_PARAM_RENDER] = render;\n        }\n\n        (window?.faces ?? window.jsf).ajax.request(source, event, options);\n    }\n\n    /**\n     * legacy oam functions\n     */\n    export const oam = _oam;\n}\n\n\n","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {IListener} from \"./util/IListener\";\nimport {Response} from \"./xhrCore/Response\";\nimport {XhrRequest} from \"./xhrCore/XhrRequest\";\nimport {AsynchronousQueue} from \"./util/AsyncQueue\";\nimport {AssocArrayCollector, Config, DQ, Lang, LazyStream, Optional, Stream} from \"mona-dish\";\nimport {Assertions} from \"./util/Assertions\";\nimport {XhrFormData} from \"./xhrCore/XhrFormData\";\nimport {ExtDomquery} from \"./util/ExtDomQuery\";\nimport {ErrorData} from \"./xhrCore/ErrorData\";\nimport {EventData} from \"./xhrCore/EventData\";\nimport {ExtLang} from \"./util/Lang\";\n\nimport {\n    $nsp,\n    CTX_PARAM_EXECUTE,\n    CTX_PARAM_PASS_THR,\n    CTX_PARAM_SRC_CTL_ID,\n    CTX_PARAM_SRC_FRM_ID,\n    CTX_PARAM_TR_TYPE,\n    IDENT_ALL,\n    IDENT_FORM,\n    IDENT_NONE,\n    IDENT_THIS,\n    MYFACES,\n    ON_ERROR,\n    ON_EVENT,\n    P_AJAX,\n    P_CLIENT_WINDOW,\n    P_EVT,\n    P_EXECUTE,\n    P_PARTIAL_SOURCE,\n    P_RENDER,\n    P_RESET_VALUES,\n    P_WINDOW_ID,\n    CTX_PARAM_RENDER,\n    REQ_TYPE_POST,\n    SOURCE,\n    TAG_FORM\n} from \"./core/Const\";\nimport {\n    resolveDefaults,\n    resolveDelay,\n    resolveForm,\n    resolveTimeout\n} from \"./xhrCore/RequestDataResolver\";\n\n\ndeclare var faces: any;\n\n/*\n * allowed project stages\n */\nenum ProjectStages {\n    Production = \"Production\",\n    Development = \"Development\",\n    SystemTest = \"SystemTest\",\n    UnitTest = \"UnitTest\"\n}\n\n/*\n *   blockfilter for the passthrough filtering; the attributes given here\n *   will not be transmitted from the options into the passthrough\n */\nenum BlockFilter {\n    onerror = \"onerror\",\n    onevent = \"onevent\",\n    render = \"render\",\n    execute = \"execute\",\n    myfaces = \"myfaces\",\n    delay = \"delay\",\n    timeout = \"timeout\",\n    windowId = \"windowId\"\n}\n\n/**\n * Core Implementation\n * to distinct between api and impl\n *\n * The original idea was to make the implementation pluggable\n * but this is pointless, you always can overwrite the thin api layer\n * however a dedicated api makes sense for readability reasons\n */\nexport module Implementation {\n/*\n Small internal explanation, this code is optimized for readability\n and cuts off a ton of old legacy code.\n Aka older browsers are not supported anymore.\n We use a self written helper library to keep the number of exernal\n code dependencies down.\n The library is called mona-dish and started as a small sideproject of mine\n it provides following\n\n a) Monad like structures for querying because this keeps the code denser and adds abstractions\n that always was the strong point of jquery and it still is better in this regard than what ecmascript provides\n\n b) Streams and lazystreams like java has, a pull like construct, ecmascript does not have anything like Lazystreams.\n Another option would have been rxjs but that would have introduced a code dependency and probably more code. We might\n move to RXJS if the need arises however. But for now I would rather stick with my small self grown library which works\n quite well and where I can patch quickly (I have used it in several industrial projects, so it works well\n and is heavily fortified by unit tests (140 testcases as time of writing this))\n\n c) A neutral json like configuration which allows assignments of arbitrary values with reduce code which then can be\n transformed into different data representations\n\n examples:\n internalCtx.assign(MYPARAM, CTX_PARAM_SRC_FRM_ID).value = form.id.value;\n passes a value into context.MYPARAM.CTX_PARAM_SRC_FRM_ID\n\n basically an abbreviation for\n\n internalCtxt[MYPARAM] = internalCtxt?.[MYPARAM] ?  internalCtxt[MYPARAM] : {};\n internalCtxt[MYPARAM][CTX_PARAM_SRC_FRM_ID] = internalCtxt?.[MYPARAM][CTX_PARAM_SRC_FRM_ID] ?  internalCtxt[MYPARAM][CTX_PARAM_SRC_FRM_ID] : {};\n internalCtxt[MYPARAM][CTX_PARAM_SRC_FRM_ID] = form.id.value;\n\n\n internalCtx.assign(condition, MYPARAM, CTX_PARAM_SRC_FRM_ID).value = form.id.value;\n passes a value into context.MYPARAM.CTX_PARAM_SRC_FRM_ID if condition === true otherwise it is ignored\n\n abbreviates:\n if(condition) {\n    internalCtxt[MYPARAM] = internalCtxt?.[MYPARAM] ?  internalCtxt[MYPARAM] : {};\n    internalCtxt[MYPARAM][CTX_PARAM_SRC_FRM_ID] = internalCtxt?.[MYPARAM][CTX_PARAM_SRC_FRM_ID] ?  internalCtxt[MYPARAM][CTX_PARAM_SRC_FRM_ID] : {};\n    internalCtxt[MYPARAM][CTX_PARAM_SRC_FRM_ID] = form.id.value;\n }\n\n\n d) Optional constructs, while under heavy debate we only use them lightly where the api requires it from mona-dish\n\n Note the inclusion of this library uses a reduced build which only includes the part of it, which we really use\n\n */\n\n    import trim = Lang.trim;\n    import getMessage = ExtLang.getMessage;\n    import getGlobalConfig = ExtLang.getGlobalConfig;\n    import assert = Assertions.assert;\n\n    let projectStage: string = null;\n    let separator: string = null;\n    let eventQueue = [];\n    let errorQueue = [];\n    export let requestQueue: AsynchronousQueue<XhrRequest> = null;\n    /*error reporting threshold*/\n    let threshold = \"ERROR\";\n\n    /**\n     * fetches the separator char from the given script tags\n     *\n     * @return {string} the separator char for the given script tags\n     */\n    export function getSeparatorChar(): string {\n        return resolveGlobalConfig()?.separator ??\n            this?.separator ??\n            (separator = ExtDomquery.searchJsfJsFor(/separator=([^&;]*)/).orElse(\":\").value);\n    }\n\n    /**\n     * fetches the separator char from the given script tags\n     *\n     * @return {string} the separator char for the given script tags\n     */\n    export function getContextPath(): string {\n        return resolveGlobalConfig()?.separator ??\n            this?.separator ??\n            (separator = ExtDomquery.searchJsfJsFor(/separator=([^&;]*)/).orElse(\":\").value);\n    }\n\n\n    /**\n     * this is for testing purposes only, since AjaxImpl is a module\n     * we need to reset for every unit test its internal states\n     */\n    export function reset() {\n        projectStage = null;\n        separator = null;\n        eventQueue = [];\n        errorQueue = [];\n        requestQueue = null;\n    }\n\n    /**\n     * @return the project stage also emitted by the server:\n     * it cannot be cached and must be delivered over the server\n     * The value for it comes from the requestInternal parameter of the faces.js script called \"stage\".\n     */\n    export function getProjectStage(): string | null {\n        return resolveGlobalConfig()?.projectStage ??\n            this?.projectStage ??\n            (projectStage = resolveProjectStateFromURL());\n    }\n\n    /**\n     * resolves the project stage as url parameter\n     * @return the project stage or null\n     */\n    export function resolveProjectStateFromURL(): string | null {\n\n        /* run through all script tags and try to find the one that includes faces.js */\n        const foundStage = ExtDomquery.searchJsfJsFor(/stage=([^&;]*)/).value as string;\n        return (foundStage in ProjectStages) ? foundStage : null;\n    }\n\n    /**\n     * implementation of the faces.util.chain functionality\n     *\n     * @param source\n     * @param event\n     * @param funcs\n     */\n    export function chain(source: any, event: Event, ...funcs: EvalFuncs): boolean {\n        // we can use our lazy stream each functionality to run our chain here..\n        // by passing a boolean as return value into the onElem call\n        // we can stop early at the first false, just like the spec requests\n\n        return LazyStream.of(...funcs)\n            .map(func => resolveAndExecute(source, event, func))\n            // we use the return false == stop as an early stop, onElem stops at the first false\n            .onElem((opResult: boolean) => opResult)\n            //last ensures we run until the first false is returned\n            .last().value;\n    }\n\n    /**\n     * this function has to send the ajax requests\n     *\n     * following request conditions must be met:\n     * <ul>\n     *  <li> the request must be sent asynchronously! </li>\n     *  <li> the request must be a POST!!! request </li>\n     *  <li> the request url must be the form action attribute </li>\n     *  <li> all requests must be queued with a client side request queue to ensure the request ordering!</li>\n     * </ul>\n     *\n     * @param el any dom element no matter being it html or jsf, from which the event is emitted\n     * @param event any javascript event supported by that object\n     * @param opts  map of options being pushed into the ajax cycle\n     *\n     * a) transformArguments out of the function\n     * b) passThrough handling with a map copy with a filter map block map\n     */\n    export function request(el: ElemDef, event?: Event, opts ?: Options) {\n\n        const {\n            resolvedEvent,\n            options,\n            elem,\n            elementId,\n            requestCtx,\n            internalCtx,\n            windowId,\n            isResetValues\n        } = resolveDefaults(event, opts, el);\n\n        Assertions.assertRequestIntegrity(options, elem);\n\n        /**\n         * fetch the parent form\n         *\n         * note we also add an override possibility here\n         * so that people can use dummy forms and work\n         * with detached objects\n         */\n        const form: DQ = resolveForm(requestCtx, elem, resolvedEvent);\n        const formId = form.id.value;\n        const delay: number = resolveDelay(options);\n        const timeout: number = resolveTimeout(options);\n\n        requestCtx.assignIf(!!windowId, P_WINDOW_ID).value = windowId;\n\n        requestCtx.assign(CTX_PARAM_PASS_THR).value = filterPassthroughValues(options.value);\n        requestCtx.assignIf(!!resolvedEvent, CTX_PARAM_PASS_THR, P_EVT).value = resolvedEvent?.type;\n\n        /**\n         * ajax pass through context with the source\n         * onresolved Event and onerror Event\n         */\n        requestCtx.assign(SOURCE).value = elementId;\n\n        /**\n         * on resolvedEvent and onError...\n         * those values will be traversed later on\n         * also into the response context\n         */\n        requestCtx.assign(ON_EVENT).value = options.value?.onevent;\n        requestCtx.assign(ON_ERROR).value = options.value?.onerror;\n\n        /**\n         * lets drag the myfaces config params also in\n         */\n        requestCtx.assign(MYFACES).value = options.value?.myfaces;\n\n        /**\n         * binding contract the jakarta.faces.source must be set\n         */\n        requestCtx.assign(CTX_PARAM_PASS_THR, P_PARTIAL_SOURCE).value = elementId;\n\n        /**\n         * jakarta.faces.partial.ajax must be set to true\n         */\n        requestCtx.assign(CTX_PARAM_PASS_THR, P_AJAX).value = true;\n\n        /**\n         * if resetValues is set to true\n         * then we have to set jakarta.faces.resetValues as well\n         * as pass through parameter\n         * the value has to be explicitly true, according to\n         * the specs jsdoc\n         */\n        requestCtx.assignIf(isResetValues, CTX_PARAM_PASS_THR, P_RESET_VALUES).value = true;\n\n        // additional meta information to speed things up, note internal non jsf\n        // pass through options are stored under _mfInternal in the context\n        internalCtx.assign(CTX_PARAM_SRC_FRM_ID).value = formId;\n\n        // mojarra compatibility, mojarra is sending the form id as well\n        // this is not documented behavior but can be determined by running\n        // mojarra under blackbox conditions.\n        // I assume it does the same as our formId_submit=1 so leaving it out\n        // won't hurt but for the sake of compatibility we are going to add it\n        requestCtx.assign(CTX_PARAM_PASS_THR, formId).value = formId;\n        internalCtx.assign(CTX_PARAM_SRC_CTL_ID).value = elementId;\n        internalCtx.assign(CTX_PARAM_TR_TYPE).value = REQ_TYPE_POST;\n\n        assignClientWindowId(form, requestCtx);\n        assignExecute(options, requestCtx, form, elementId);\n        assignRender(options, requestCtx, form, elementId);\n\n        //now we enqueue the request as asynchronous runnable into our request\n        //queue and let the queue take over the rest\n        queueHandler.addRequestToQueue(elem, form, requestCtx, internalCtx, delay, timeout);\n    }\n\n    /**\n     * Spec. 13.3.3\n     * Examining the response markup and updating the DOM tree\n     * @param {XMLHttpRequest} request - the ajax request\n     * @param {Object} context - the ajax context\n     */\n    export function response(request: XMLHttpRequest, context: Context) {\n        Response.processResponse(request, context);\n    }\n\n    /**\n     * adds an error handler to the error queue\n     *\n     * @param errorListener the error listener handler\n     */\n    export function addOnError(errorListener: IListener<ErrorData>) {\n        errorQueue.push(errorListener);\n    }\n\n    /**\n     * adds an event handler to the event queue\n     *\n     * @param eventListener the event listener handler\n     */\n    export function addOnEvent(eventListener: IListener<EventData>) {\n        eventQueue.push(eventListener);\n    }\n\n    // noinspection JSUnusedLocalSymbols\n    /**\n     * sends an event to the event handlers\n     *\n     * @param data the event data object hosting the event data according to the spec @see EventData for what is reachable\n     * @param localHandler an optional event handler, which is processed before the event handler chain\n     */\n    export function sendEvent(data: EventData, localHandler = function (data: EventData) {\n    }) {\n        /*now we serve the queue as well*/\n        localHandler(data);\n        eventQueue.forEach(fn => fn(data));\n    }\n\n    /**\n     * error handler behavior called internally\n     * and only into the impl it takes care of the\n     * internal message transformation to a myfaces internal error\n     * and then uses the standard send error mechanisms\n     * also a double error logging prevention is done as well\n     *\n     * @param request the request currently being processed\n     * @param context the context affected by this error\n     * @param exception the exception being thrown\n     * @param clearRequestQueue if set to true, clears the request queue of all pending requests\n     */\n    export function stdErrorHandler(request: XMLHttpRequest,\n                                    context: Config,\n                                    exception: Error,\n                                    clearRequestQueue = false) {\n        //newer browsers do not allow to hold additional values on native objects like exceptions\n        //we hence capsule it into the request, which is gced automatically\n        //on ie as well, since the stdErrorHandler usually is called between requests\n        //this is a valid approach\n        try {\n            if (threshold == \"ERROR\") {\n                let errorData = ErrorData.fromClient(exception);\n                sendError(errorData);\n            }\n        } finally {\n            if (clearRequestQueue) {\n                requestQueue.cleanup();\n            }\n        }\n    }\n\n    // noinspection JSUnusedLocalSymbols\n    /**\n     * implementation triggering the error chain\n     *\n     *\n     *\n     *  handles the errors, in case of an onError exists within the context the onError is called as local error handler\n     *  the registered error handlers in the queue received an error message to be dealt with\n     *  and if the projectStage is at development an alert box is displayed\n     *\n     *  note: we have additional functionality here, via the global config myfaces.config.defaultErrorOutput a function can be provided\n     *  which changes the default output behavior from alert to something else\n     *\n     * @param errorData the error data to be displayed\n     * @param localHandler an optional local error handler which has to be processed before the error handler queue\n     */\n    export function sendError(errorData: ErrorData, localHandler = function (data: ErrorData) {\n    }) {\n\n        localHandler(errorData);\n        errorQueue.forEach((errorCallback: Function) => {\n            errorCallback(errorData);\n        });\n        let displayError: (string) => void = getGlobalConfig(\"defaultErrorOutput\", (console ? console.error : alert));\n        displayError(errorData);\n    }\n\n    /**\n     * @node optional element or id defining a rootnode where an element with the id \"jakarta.faces.windowId\" is hosted\n     * @return the client window id of the current window, if one is given if none is found, null is returned\n     */\n    export function getClientWindow(node ?: Element | string): string | null {\n        const ALTERED = \"___mf_id_altered__\";\n        const INIT = \"___init____\";\n\n        /**\n         * the search root for the dom element search\n         */\n        let searchRoot = new DQ(node || document.body).querySelectorAll(`form input [name='${P_CLIENT_WINDOW}']`);\n\n        /**\n         * lazy helper to fetch the window id from the window url\n         */\n        let fetchWindowIdFromUrl = () => ExtDomquery.searchJsfJsFor(/jfwid=([^&;]*)/).orElse(null).value;\n\n        /**\n         * functional double check based on stream reduction\n         * the values should be identical or on INIT value which is a premise to\n         * skip the first check\n         *\n         * @param value1\n         * @param value2\n         */\n        let differenceCheck = (value1: string, value2: string) => {\n            if(value1 == INIT) {\n                return value2;\n            } else if (value1 == ALTERED || value1 != value2) {\n                return ALTERED;\n            }\n            return value2;\n        };\n\n        /**\n         * helper for cleaner code, maps the value from an item\n         *\n         * @param item\n         */\n        let getValue = (item: DQ) => item.attr(\"value\").value;\n        /**\n         * fetch the window id from the forms\n         * window ids must be present in all forms\n         * or non existent. If they exist all of them must be the same\n         */\n\n        let formWindowId: Optional<string> = searchRoot.stream.map<string>(getValue).reduce(differenceCheck, INIT);\n\n\n        //if the resulting window id is set on altered then we have an unresolvable problem\n        assert(ALTERED != formWindowId.value, \"Multiple different windowIds found in document\");\n\n        /**\n         * return the window id or null\n         * prio, forms under node/document and if not given then from the url\n         */\n        return formWindowId.value != INIT ? formWindowId.value : fetchWindowIdFromUrl();\n    }\n\n    /**\n     * collect and encode data for a given form element (must be of type form)\n     * find the jakarta.faces.ViewState element and encode its value as well!\n     * @return a concatenated string of the encoded values!\n     *\n     * @throws Error in case of the given element not being of type form!\n     * https://issues.apache.org/jira/browse/MYFACES-2110\n     */\n    export function getViewState(form: Element | string): string {\n        /**\n         *  typecheck assert!, we opt for strong typing here\n         *  because it makes it easier to detect bugs\n         */\n\n        let element: DQ = DQ.byId(form, true);\n        if (!element.isTag(TAG_FORM)) {\n            throw new Error(getMessage(\"ERR_VIEWSTATE\"));\n        }\n\n        let formData = new XhrFormData(element);\n        return formData.toString();\n    }\n\n    /**\n     * this at the first sight looks like a weird construct, but we need to do it this way\n     * for testing, we cannot proxy addRequestToQueue from the testing frameworks directly,\n     * but we need to keep it under unit tests.\n     */\n    export let queueHandler = {\n        /**\n         * public to make it shimmable for tests\n         *\n         * adds a new request to our queue for further processing\n         */\n        addRequestToQueue: function (elem: DQ, form: DQ, reqCtx: Config, respPassThr: Config, delay = 0, timeout = 0) {\n            requestQueue = requestQueue ?? new AsynchronousQueue<XhrRequest>();\n            requestQueue.enqueue(new XhrRequest(elem, form, reqCtx, respPassThr, [], timeout), delay);\n        }\n    };\n\n    //----------------------------------------------- Methods ---------------------------------------------------------------------\n\n    /**\n     * the idea is to replace some placeholder parameters with their respective values\n     * placeholder params like  @all, @none, @form, @this need to be replaced by\n     * the values defined by the specification\n     *\n     * This function does it for the render parameters\n     *\n     * @param requestOptions the source options coming in as options object from faces.ajax.request (options parameter)\n     * @param targetContext the receiving target context\n     * @param issuingForm the issuing form\n     * @param sourceElementId the executing element triggering the faces.ajax.request (id of it)\n     */\n    function assignRender(requestOptions: Config, targetContext: Config, issuingForm: DQ, sourceElementId: string) {\n        if (requestOptions.getIf(CTX_PARAM_RENDER).isPresent()) {\n            remapDefaultConstants(targetContext.getIf(CTX_PARAM_PASS_THR).get({}), P_RENDER, <string>requestOptions.getIf(CTX_PARAM_RENDER).value, issuingForm, <any>sourceElementId);\n        }\n    }\n\n    /**\n     * the idea is to replace some placeholder parameters with their respective values\n     * placeholder params like  @all, @none, @form, @this need to be replaced by\n     * the values defined by the specification\n     *\n     * This function does it for the execute parameters\n     *\n     * @param requestOptions the source options coming in as options object from faces.ajax.request (options parameter)\n     * @param targetContext the receiving target context\n     * @param issuingForm the issuing form\n     * @param sourceElementId the executing element triggering the faces.ajax.request (id of it)\n     */\n    function assignExecute(requestOptions: Config, targetContext: Config, issuingForm: DQ, sourceElementId: string) {\n\n        if (requestOptions.getIf(CTX_PARAM_EXECUTE).isPresent()) {\n            /*the options must be a blank delimited list of strings*/\n            /*compliance with Mojarra which automatically adds @this to an execute\n             * the spec rev 2.0a however states, if none is issued nothing at all should be sent down\n             */\n            requestOptions.assign(CTX_PARAM_EXECUTE).value = [requestOptions.getIf(CTX_PARAM_EXECUTE).value, IDENT_THIS].join(\" \");\n            remapDefaultConstants(targetContext.getIf(CTX_PARAM_PASS_THR).get({}), P_EXECUTE, <string>requestOptions.getIf(CTX_PARAM_EXECUTE).value, issuingForm, <any>sourceElementId);\n        } else {\n            targetContext.assign(CTX_PARAM_PASS_THR, P_EXECUTE).value = sourceElementId;\n        }\n    }\n\n    /**\n     * apply the browser tab where the request was originating from\n     *\n     * @param form the form hosting the client window id\n     * @param targetContext the target context receiving the value\n     */\n    function assignClientWindowId(form: DQ, targetContext: Config) {\n\n        let clientWindow = (window?.faces ?? window?.jsf).getClientWindow(form.getAsElem(0).value);\n        if (clientWindow) {\n            targetContext.assign(CTX_PARAM_PASS_THR, P_CLIENT_WINDOW).value = clientWindow;\n        }\n    }\n\n    /**\n     * transforms the user values to the expected one\n     * with the proper none all form and this handling\n     * (note we also could use a simple string replace but then\n     * we would have had double entries under some circumstances)\n     *\n     * there are several standardized constants which need a special treatment\n     * like @all, @none, @form, @this\n     *\n     * @param targetConfig the target configuration receiving the final values\n     * @param targetKey the target key\n     * @param userValues the passed user values (aka input string which needs to be transformed)\n     * @param issuingForm the form where the issuing element originates\n     * @param issuingElementId the issuing element\n     */\n    function remapDefaultConstants(targetConfig: Config, targetKey: string, userValues: string, issuingForm: DQ, issuingElementId: string): Config {\n        //a cleaner implementation of the transform list method\n\n        let iterValues: string[] = (userValues) ? trim(userValues).split(/\\s+/gi) : [];\n        let ret = [];\n        let processed: {[key: string]: boolean} = {};\n\n        // in this case we do not use lazy stream because it wont bring any code reduction\n        // or speedup\n        for (let cnt = 0; cnt < iterValues.length; cnt++) {\n            //avoid doubles\n            if (iterValues[cnt] in processed) {\n                continue;\n            }\n            switch (iterValues[cnt]) {\n                //@none no values should be sent\n                case IDENT_NONE:\n                    return targetConfig.delete(targetKey);\n                //@all is a pass through case according to the spec\n                case IDENT_ALL:\n                    targetConfig.assign(targetKey).value = IDENT_ALL;\n                    return targetConfig;\n                //@form pushes the issuing form id into our list\n                case IDENT_FORM:\n                    ret.push(issuingForm.id.value);\n                    processed[issuingForm.id.value] = true;\n                    break;\n                //@this is replaced with the current issuing element id\n                case IDENT_THIS:\n                    if (!(issuingElementId in processed)) {\n                        ret.push(issuingElementId);\n                        processed[issuingElementId] = true;\n                    }\n                    break;\n                default:\n                    ret.push(iterValues[cnt]);\n                    processed[iterValues[cnt]] = true;\n            }\n        }\n        //We now add the target as joined list\n        targetConfig.assign(targetKey).value = ret.join(\" \");\n        return targetConfig;\n    }\n\n    /**\n     * filter the options given with a blacklist so that only\n     * the values required for passthough land in the ajax request\n     *\n     * @param {Context} mappedOpts the options to be filtered\n     */\n    function filterPassthroughValues(mappedOpts: Context): Context {\n        //we now can use the full code reduction given by our stream api\n        //to filter\n        return Stream.ofAssoc(mappedOpts)\n            .filter(item => !(item[0] in BlockFilter))\n            .collect(new AssocArrayCollector());\n    }\n\n    function resolveGlobalConfig(): any {\n        return  window?.[MYFACES]?.config ?? {};\n    }\n\n    /**\n     * Private helper to execute a function or code fragment\n     * @param source the source of the caller passed into the function as this\n     * @param event an event which needs to be passed down into the function\n     * @param func either a function or code fragment\n     * @return a boolean value, if the passed function returns false, then the\n     * caller is basically notified that the execution can now stop (JSF requirement for chain)\n     * @private\n     */\n    function resolveAndExecute(source: any, event: Event, func: Function | string): boolean {\n        if (\"string\" != typeof func) {\n            //function is passed down as chain parameter, can be executed as is\n            return (<Function>func).call(source, event) !== false;\n        } else {\n            //either a function or a string can be passed in case of a string we have to wrap it into another function\n            //it is not a plain executable code but a definition\n            let sourceCode = trim(<string>func);\n            if (sourceCode.indexOf(\"function \") == 0) {\n                sourceCode = `return ${sourceCode} (event)`;\n            }\n            return new Function(\"event\", sourceCode).call(source, event) !== false;\n        }\n    }\n}\n","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Typescript port of the faces.push part in the myfaces implementation\n */\n\n//TODO still work in progress\n//this is a 1:1 port for the time being\nimport {MAX_RECONNECT_ATTEMPTS, REASON_EXPIRED, RECONNECT_INTERVAL} from \"./core/Const\";\n;\n\n\n/**\n * Implementation class for the push functionality\n */\nexport module PushImpl {\n\n    const URL_PROTOCOL = window.location.protocol.replace(\"http\", \"ws\") + \"//\";\n\n\n    //we expose the member variables for testing purposes\n    //they are not directly touched outside of tests\n\n    /* socket map by token */\n    export let sockets = {};\n    /* component attributes by clientId */\n    export let components = {};\n    /* client ids by token (share websocket connection) */\n    export let clientIdsByTokens = {};\n\n\n    //needed for testing\n    export function reset() {\n        sockets = {};\n        components = {}\n        clientIdsByTokens = {}\n    }\n\n    /*\n     * Api implementations, exposed functions\n     */\n\n    /**\n     *\n     * @param {function} onopen The function to be invoked when the web socket is opened.\n     * @param {function} onmessage The function to be invoked when a message is received.\n     * @param {function} onclose The function to be invoked when the web socket is closed.\n     * @param {boolean} autoconnect Whether or not to immediately open the socket. Defaults to <code>false</code>.\n     */\n    export function init(socketClientId: string,\n                         uri: string,\n                         channel: string,\n                         onopen: Function,\n                         onmessage: Function,\n                         onclose: Function,\n                         behaviorScripts: any,\n                         autoconnect: boolean) {\n        onclose = resolveFunction(onclose);\n\n        if (!window.WebSocket) { // IE6-9.\n            onclose(-1, channel);\n            return;\n        }\n\n        let channelToken = uri.substr(uri.indexOf('?') + 1);\n\n        if (!components[socketClientId]) {\n            components[socketClientId] = {\n                'channelToken': channelToken,\n                'onopen': resolveFunction(onopen),\n                'onmessage' : resolveFunction(onmessage),\n                'onclose': onclose,\n                'behaviors': behaviorScripts,\n                'autoconnect': autoconnect};\n            if (!clientIdsByTokens[channelToken]) {\n                clientIdsByTokens[channelToken] = [];\n            }\n            clientIdsByTokens[channelToken].push(socketClientId);\n            if (!sockets[channelToken]){\n                sockets[channelToken] = new Socket(channelToken,\n                    getBaseURL(uri), channel);\n            }\n        }\n\n        if (autoconnect) {\n            (window?.faces ?? window?.jsf).push.open(socketClientId);\n        }\n    }\n\n    export function open(socketClientId: string) {\n        getSocket(components?.[socketClientId]?.channelToken).open();\n    }\n\n    export function close(socketClientId: string) {\n        getSocket(components?.[socketClientId].channelToken).close();\n    }\n\n    // Private helper classes\n    // Private classes functions ----------------------------------------------------------------------------------\n    /**\n     * Creates a reconnecting web socket. When the web socket successfully connects on first attempt, then it will\n     * automatically reconnect on timeout with cumulative intervals of 500ms with a maximum of 25 attempts (~3 minutes).\n     * The <code>onclose</code> function will be called with the error code of the last attempt.\n     * @constructor\n     * @param {string} channelToken the channel token associated with this websocket connection\n     * @param {string} url The URL of the web socket\n     * @param {string} channel The name of the web socket channel.\n     */\n\n    class Socket {\n\n        socket: WebSocket;\n        reconnectAttempts = 0;\n\n        constructor(private channelToken: string, private url: string, private channel: string) {\n        }\n\n        open() {\n            if (this.socket && this.socket.readyState == 1) {\n                return;\n            }\n            this.socket = new WebSocket(this.url);\n\n            this.bindCallbacks();\n        }\n\n        onopen(event: any) {\n            if (!this.reconnectAttempts) {\n                let clientIds = clientIdsByTokens[this.channelToken];\n                for (let i = clientIds.length - 1; i >= 0; i--) {\n                    let socketClientId = clientIds[i];\n                    components[socketClientId]['onopen'](this.channel);\n                }\n            }\n            this.reconnectAttempts = 0;\n        }\n\n        onmmessage(event: any) {\n            let message = JSON.parse(event.data);\n            for (let i = clientIdsByTokens[this.channelToken].length - 1; i >= 0; i--) {\n                let socketClientId = clientIdsByTokens[this.channelToken][i];\n                if (document.getElementById(socketClientId)) {\n                    try {\n                        components[socketClientId]['onmessage'](message, this.channel, event);\n                    } catch (e) {\n                        //Ignore\n                    }\n                    let behaviors = components[socketClientId]['behaviors'];\n                    let functions = behaviors[message];\n                    if (functions && functions.length) {\n                        for (let j = 0; j < functions.length; j++) {\n                            try {\n                                functions[j](null);\n                            } catch (e) {\n                                //Ignore\n                            }\n                        }\n                    }\n                } else {\n                    clientIdsByTokens[this.channelToken].splice(i, 1);\n                }\n            }\n            if (clientIdsByTokens[this.channelToken].length == 0) {\n                //tag dissapeared\n                this.close();\n            }\n        }\n\n        onclose(event: any) {\n            if (!this.socket\n                || (event.code == 1000 && event.reason == REASON_EXPIRED)\n                || (event.code == 1008)\n                || (!this.reconnectAttempts)\n                || (this.reconnectAttempts >= MAX_RECONNECT_ATTEMPTS)) {\n                let clientIds = clientIdsByTokens[this.channelToken];\n                for (let i = clientIds.length - 1; i >= 0; i--) {\n                    let socketClientId = clientIds[i];\n                    components[socketClientId]['onclose'](event?.code, this?.channel, event);\n                }\n            } else {\n                setTimeout(this.open, RECONNECT_INTERVAL * this.reconnectAttempts++);\n            }\n        };\n\n        close() {\n            if (this.socket) {\n                let s = this.socket;\n                this.socket = null;\n                s.close();\n            }\n        }\n\n        /**\n         * bind the callbacks to the socket callbacks\n         */\n        private bindCallbacks() {\n            this.socket.onopen = (event: Event) => this.onopen(event);\n            this.socket.onmessage = (event: Event) => this.onmmessage(event);\n            this.socket.onclose = (event: Event) => this.onclose(event);\n        }\n    }\n\n    // Private static functions ---------------------------------------------------------------------------------------\n\n    function getBaseURL(url: string) {\n        if (url.indexOf(\"://\") < 0) {\n            let base = window.location.hostname + \":\" + window.location.port;\n            return URL_PROTOCOL + base + url;\n        } else {\n            return url;\n        }\n    }\n\n    /**\n     * Get socket associated with given channelToken.\n     * @param {string} channelToken The name of the web socket channelToken.\n     * @return {Socket} Socket associated with given channelToken.\n     * @throws {Error} When channelToken is unknown, you may need to initialize\n     *                 it first via <code>init()</code> function.\n     */\n    function getSocket(channelToken: string): Socket {\n        let socket = sockets[channelToken];\n        if (socket) {\n            return socket;\n        } else {\n            throw new Error(\"Unknown channelToken: \" + channelToken);\n        }\n    }\n\n    function resolveFunction(fn: Function | string = () => {\n    }): Function {\n        return <Function>((typeof fn !== \"function\") && (fn = window[fn]), fn);\n    }\n\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * [export const] constants\n */\nexport const P_PARTIAL_SOURCE = \"jakarta.faces.source\";\nexport const PARTIAL_ID = \"partialId\";\nexport const P_VIEWSTATE = \"jakarta.faces.ViewState\";\nexport const P_VIEWROOT = \"jakarta.faces.ViewRoot\";\nexport const P_VIEWHEAD = \"jakarta.faces.ViewHead\";\nexport const P_VIEWBODY = \"jakarta.faces.ViewBody\";\n\nexport const P_RESOURCE = \"jakarta.faces.Resource\";\n\n/*some useful definitions*/\n\nexport const EMPTY_FUNC = Object.freeze(() => {\n});\nexport const EMPTY_STR = \"\";\nexport const EMPTY_MAP = Object.freeze({});\n\nexport const HTML_VIEWSTATE = [\"<input type='hidden'\", \"id='\", P_VIEWSTATE, \"' name='\", P_VIEWSTATE, \"' value='' />\"].join(EMPTY_STR);\n\n\n/*internal identifiers for options*/\nexport const IDENT_ALL = \"@all\";\nexport const IDENT_NONE = \"@none\";\nexport const IDENT_THIS = \"@this\";\nexport const IDENT_FORM = \"@form\";\n\n\nexport const P_AJAX = \"jakarta.faces.partial.ajax\";\nexport const P_EXECUTE = \"jakarta.faces.partial.execute\";\nexport const P_RENDER = \"jakarta.faces.partial.render\";\nexport const P_EVT = \"jakarta.faces.partial.event\";\nexport const P_CLIENT_WINDOW = \"jakarta.faces.ClientWindow\";\nexport const P_RESET_VALUES = \"jakarta.faces.partial.resetValues\";\nexport const P_WINDOW_ID = \"jakarta.faces.windowId\";\n\nexport const P_BEHAVIOR_EVENT = \"jakarta.faces.behavior.event\";\n\nexport const CTX_PARAM_RENDER = \"render\";\nexport const WINDOW_ID = \"windowId\";\n\n/* message types */\nexport const ERROR = \"error\";\nexport const EVENT = \"event\";\n\nexport const ON_ERROR = \"onerror\";\nexport const ON_EVENT = \"onevent\";\n\n/* event emitting stages */\nexport const BEGIN = \"begin\";\nexport const COMPLETE = \"complete\";\nexport const SUCCESS = \"success\";\n\nexport const SOURCE = \"source\";\nexport const STATUS = \"status\";\n\n\nexport const ERROR_NAME = \"error-name\";\nexport const ERROR_MESSAGE = \"error-message\";\n\n\nexport const RESPONSE_TEXT = \"responseText\";\nexport const RESPONSE_XML = \"responseXML\";\n\n/*ajax errors spec 14.4.2*/\nexport const HTTPERROR = \"httpError\";\nexport const EMPTY_RESPONSE = \"emptyResponse\";\nexport const MALFORMEDXML = \"malformedXML\";\nexport const SERVER_ERROR = \"serverError\";\nexport const CLIENT_ERROR = \"clientError\";\nexport const TIMEOUT_EVENT = \"timeout\";\n\nexport const CTX_PARAM_MF_INTERNAL = \"_mfInternal\";\n\nexport const CTX_PARAM_SRC_FRM_ID = \"_mfSourceFormId\";\nexport const CTX_PARAM_SRC_CTL_ID = \"_mfSourceControlId\";\nexport const CTX_PARAM_TR_TYPE = \"_mfTransportType\";\nexport const CTX_PARAM_PASS_THR = \"passThrgh\";\nexport const CTX_PARAM_DELAY = \"delay\";\nexport const CTX_PARAM_TIMEOUT = \"timeout\";\nexport const CTX_PARAM_RST = \"resetValues\";\nexport const CTX_PARAM_EXECUTE = \"execute\";\n\nexport const STAGE_DEVELOPMENT = \"Development\";\n\n\nexport const CONTENT_TYPE = \"Content-Type\";\nexport const HEAD_FACES_REQ = \"Faces-Request\";\nexport const REQ_ACCEPT = \"Accept\";\nexport const VAL_AJAX = \"partial/ajax\";\nexport const ENCODED_URL = \"jakarta.faces.encodedURL\";\nexport const REQ_TYPE_GET = \"GET\";\nexport const REQ_TYPE_POST = \"POST\";\nexport const STATE_EVT_BEGIN = \"begin\"; //TODO remove this\nexport const STATE_EVT_TIMEOUT = \"TIMEOUT_EVENT\";\nexport const STATE_EVT_COMPLETE = \"complete\"; //TODO remove this\nexport const URL_ENCODED = \"application/x-www-form-urlencoded\";\nexport const MULTIPART = \"multipart/form-data\";\nexport const NO_TIMEOUT = 0;\nexport const STD_ACCEPT = \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\";\n\nexport const TAG_HEAD = \"head\";\nexport const TAG_FORM = \"form\";\nexport const TAG_BODY = \"body\";\nexport const TAG_BEFORE = \"before\";\nexport const TAG_AFTER = \"after\";\n\nexport const TAG_ATTR = \"attribute\";\n\n\nexport const SEL_VIEWSTATE_ELEM = \"[name='\" + P_VIEWSTATE + \"']\";\nexport const SEL_CLIENT_WINDOW_ELEM = \"[name='\" + P_CLIENT_WINDOW + \"']\";\nexport const SEL_RESPONSE_XML = \"responseXML\";\n\nexport const PHASE_PROCESS_RESPONSE = \"processResponse\";\n\n\nexport const ERR_NO_PARTIAL_RESPONSE = \"Partial response not set\";\n\nexport const ATTR_URL = \"url\";\nexport const ATTR_NAME = \"name\";\nexport const ATTR_VALUE = \"value\";\nexport const ATTR_ID = \"id\";\n\n/*partial response types*/\nexport const RESP_PARTIAL = \"partial-response\";\n\n/*partial commands*/\nexport const CMD_CHANGES = \"changes\";\nexport const CMD_UPDATE = \"update\";\nexport const CMD_DELETE = \"delete\";\nexport const CMD_INSERT = \"insert\";\nexport const CMD_EVAL = \"eval\";\nexport const CMD_ERROR = \"error\";\nexport const CMD_ATTRIBUTES = \"attributes\";\nexport const CMD_EXTENSION = \"extension\";\nexport const CMD_REDIRECT = \"redirect\";\n\n/*other constants*/\n\nexport const UPDATE_FORMS = \"_updateForms\";\nexport const UPDATE_ELEMS = \"_updateElems\";\n\n//we want the head elements to be processed before we process the body\n//but after the inner html is done\nexport const DEFERRED_HEAD_INSERTS = \"_headElems\";\n\nexport const MYFACES = \"myfaces\";\n\nexport const SEL_SCRIPTS_STYLES = \"script, style, link\";\n\nexport const MF_NONE = \"__mf_none__\";\n\nexport const REASON_EXPIRED = \"Expired\";\n\nexport const APPLIED_VST = \"appliedViewState\";\nexport const APPLIED_CLIENT_WINDOW = \"appliedClientWindow\";\n\nexport const RECONNECT_INTERVAL = 500;\nexport const MAX_RECONNECT_ATTEMPTS = 25;\n\nexport const UNKNOWN = \"UNKNOWN\";\n\n/**\n * helper to remap the namespaces variables for 2.3\n * from 2.3 to 4.0 every javax namespace has been changed\n * to faces\n * To take the compatibility layer out this method just has to be\n * changed to a simple value passthrough\n */\n\nexport function $nsp(inputNamespace?: any): any {\n     if((!inputNamespace) || !inputNamespace?.replace) {\n          return inputNamespace;\n     }\n     return (!!window?.faces) ? inputNamespace.replace(/javax\\.faces/gi,\"jakarta.faces\"): inputNamespace.replace(/jakarta\\.faces/gi, \"javax.faces\");\n}\n\n","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {EMPTY_STR, P_VIEWSTATE} from \"./Const\";\n\nexport interface IdValueHolder {\n\n    readonly id: string;\n    readonly value: string;\n\n}\n\n/**\n * a helper class to isolate the\n * view state and client window and other\n * future states which follow a similar pattern\n */\nexport class StateHolder implements IdValueHolder {\n\n    nameSpace: string;\n\n    constructor(public id: string, public value: string) {\n        let viewStatePos = id.indexOf(P_VIEWSTATE);\n        this.nameSpace = viewStatePos > 0 ? id.substr(0, viewStatePos - 1) : EMPTY_STR;\n    }\n\n    get hasNameSpace(): boolean {\n        return !!(this?.nameSpace ?? EMPTY_STR).length;\n    }\n}\n","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class Messages {\n    MSG_TEST = \"Testmessage\";\n\n    /*Messages*/\n    /** @constant */\n    MSG_DEV_MODE = \"Note, this message is only sent, because project stage is development and no \" +\n        \"other error listeners are registered.\";\n    /** @constant */\n    MSG_AFFECTED_CLASS = \"Affected Class=\";\n    /** @constant */\n    MSG_AFFECTED_METHOD = \"Affected Method=\";\n    /** @constant */\n    MSG_ERROR_NAME = \"Error Name=\";\n    /** @constant */\n    MSG_ERROR_MESSAGE = \"Error Message=\";\n    /** @constant */\n    MSG_SERVER_ERROR_NAME = \"Server Error Name=\";\n\n    /** @constant */\n    MSG_ERROR_DESC = \"Error Description=\";\n    /** @constant */\n    MSG_ERROR_NO = \"Error Number=\";\n    /** @constant */\n    MSG_ERROR_LINENO = \"Error Line Number=\";\n\n    /*Errors and messages*/\n    /** @constant */\n    ERR_FORM = \"Sourceform could not be determined, either because element is not attached to a form or we have multiple forms with named elements of the same identifier or name, stopping the ajax processing\";\n    /** @constant */\n    ERR_VIEWSTATE = \"faces.viewState= param value not of type form!\";\n    /** @constant */\n    ERR_TRANSPORT = \"Transport type {0} does not exist\";\n    /** @constant */\n    ERR_EVT_PASS = \"an event must be passed down (either a an event object null or undefined) \";\n    /** @constant */\n    ERR_CONSTRUCT = \"Parts of the response couldn't be retrieved when constructing the event data= {0} \";\n    /** @constant */\n    ERR_MALFORMEDXML = \"The server response could not be parsed, the server has returned with a response which is not xml !\";\n    /** @constant */\n    ERR_SOURCE_FUNC = \"source cannot be a function (probably source and event were not defined or set to null\";\n    /** @constant */\n    ERR_EV_OR_UNKNOWN = \"An event object or unknown must be passed as second parameter\";\n    /** @constant */\n    ERR_SOURCE_NOSTR = \"source cannot be a string\";\n    /** @constant */\n    ERR_SOURCE_DEF_NULL = \"source must be defined or null\";\n\n    //_Lang.js\n    /** @constant */\n    ERR_MUST_STRING = \"{0}: {1} namespace must be of type String\";\n    /** @constant */\n    ERR_REF_OR_ID = \"{0}: {1} a reference node or identifier must be provided\";\n    /** @constant */\n    ERR_PARAM_GENERIC = \"{0}: parameter {1} must be of type {2}\";\n    /** @constant */\n    ERR_PARAM_STR = \"{0}: {1} param must be of type string\";\n    /** @constant */\n    ERR_PARAM_STR_RE = \"{0}: {1} param must be of type string or a regular expression\";\n    /** @constant */\n    ERR_PARAM_MIXMAPS = \"{0}: both a source as well as a destination map must be provided\";\n    /** @constant */\n    ERR_MUST_BE_PROVIDED = \"{0}: an {1} and a {2} must be provided\";\n    /** @constant */\n    ERR_MUST_BE_PROVIDED1 = \"{0}: {1} must be set\";\n\n    /** @constant */\n    ERR_REPLACE_EL = \"replaceElements called while evalNodes is not an array\";\n\n    /** @constant */\n    ERR_EMPTY_RESPONSE = \"{0}: The response cannot be null or empty!\";\n    /** @constant */\n    ERR_ITEM_ID_NOTFOUND = \"{0}: item with identifier {1} could not be found\";\n    /** @constant */\n    ERR_PPR_IDREQ = \"{0}: Error in PPR Insert, id must be present\";\n    /** @constant */\n    ERR_PPR_INSERTBEFID = \"{0}: Error in PPR Insert, before id or after id must be present\";\n    /** @constant */\n    ERR_PPR_INSERTBEFID_1 = \"{0}: Error in PPR Insert, before  node of id {1} does not exist in document\";\n    /** @constant */\n    ERR_PPR_INSERTBEFID_2 = \"{0}: Error in PPR Insert, after  node of id {1} does not exist in document\";\n\n    /** @constant */\n    ERR_PPR_DELID = \"{0}: Error in delete, id not in xml markup\";\n    /** @constant */\n    ERR_PPR_UNKNOWNCID = \"{0}:  Unknown Html-Component-ID= {1}\";\n\n    /** @constant */\n    ERR_NO_VIEWROOTATTR = \"{0}: Changing of ViewRoot attributes is not supported\";\n    /** @constant */\n    ERR_NO_HEADATTR = \"{0}: Changing of Head attributes is not supported\";\n    /** @constant */\n    ERR_RED_URL = \"{0}: Redirect without url\";\n\n    /** @constant */\n    ERR_REQ_FAILED_UNKNOWN = \"Request failed with unknown status\";\n\n    /** @constant */\n    ERR_REQU_FAILED = \"Request failed with status {0} and reason {1}\";\n\n    /** @constant */\n    UNKNOWN = \"UNKNOWN\";\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Config, Lang, XMLQuery} from \"mona-dish\";\n\nimport {DQ} from \"mona-dish\";\nimport {ExtLang} from \"./Lang\";\nimport getMessage = ExtLang.getMessage;\nimport makeException = ExtLang.makeException;\nimport {\n    ATTR_URL,\n    EMPTY_RESPONSE,\n    EMPTY_STR, ERR_NO_PARTIAL_RESPONSE, MALFORMEDXML,\n    ON_ERROR,\n    ON_EVENT,\n    PHASE_PROCESS_RESPONSE,\n    RESP_PARTIAL\n} from \"../core/Const\";\n\n/**\n * a set of internal code assertions\n * which raise an error\n *\n */\nexport module Assertions {\n\n    export function assertRequestIntegrity(options: Config, elem: DQ): void | never {\n        /*assert if the onerror is set and once if it is set it must be of type function*/\n        assertFunction(options.getIf(ON_ERROR).value);\n        /*assert if the onevent is set and once if it is set it must be of type function*/\n        assertFunction(options.getIf(ON_EVENT).value);\n        //improve the error messages if an empty elem is passed\n        //Assertions.assertElementExists(elem);\n        assert(elem.isPresent(), getMessage(\"ERR_MUST_BE_PROVIDED1\", \"{0}: source  must be provided or exist\", \"source element id\"), \"faces.ajax.request\", \"ArgNotSet\",  )\n    }\n\n    export function assertUrlExists(node: XMLQuery): void | never {\n        if (node.attr(ATTR_URL).isAbsent()) {\n            throw Assertions.raiseError(new Error(), getMessage(\"ERR_RED_URL\", null, \"_Ajaxthis.processRedirect\"), \"processRedirect\");\n        }\n    }\n\n    /**\n     * checks the xml for various issues which can occur\n     * and prevent a proper processing\n     */\n    export function assertValidXMLResponse(responseXML: XMLQuery) : void | never  {\n        assert(!responseXML.isAbsent(), EMPTY_RESPONSE, PHASE_PROCESS_RESPONSE);\n        assert(!responseXML.isXMLParserError(),  responseXML.parserErrorText(EMPTY_STR), PHASE_PROCESS_RESPONSE);\n        assert(responseXML.querySelectorAll(RESP_PARTIAL).isPresent(), ERR_NO_PARTIAL_RESPONSE, PHASE_PROCESS_RESPONSE);\n    }\n\n    /**\n     * internal helper which raises an error in the\n     * format we need for further processing\n     *\n     * @param error\n     * @param message the message\n     * @param caller\n     * @param title the title of the error (optional)\n     * @param name the name of the error (optional)\n     */\n    export function raiseError(error: any, message: string, caller ?: string, title ?: string, name ?: string): Error {\n\n        let finalTitle = title ?? MALFORMEDXML;\n        let finalName = name ?? MALFORMEDXML;\n        let finalMessage = message ?? EMPTY_STR;\n\n        //TODO clean up the messy makeException, this is a perfect case for encapsulation and sane defaults\n        return makeException(error, finalTitle, finalName, \"Response\", caller || (((<any>arguments).caller) ? (<any>arguments).caller.toString() : \"_raiseError\"), finalMessage);\n    }\n\n    /*\n     * using the new typescript 3.7 compiler assertion functionality to improve compiler hinting\n     * we are not fully there yet, but soon\n     */\n\n    export function assert(value: any, msg = EMPTY_STR, caller=EMPTY_STR, title=\"Assertion Error\"): asserts value {\n        if(!value) {\n            throw Assertions.raiseError(new Error(), msg ,caller, title);\n        }\n    }\n\n\n    export function assertType(value: any, theType: any, msg = EMPTY_STR, caller=EMPTY_STR, title=\"Type Assertion Error\"): asserts value {\n        if((!!value) && !Lang.assertType(value,theType)) {\n            throw Assertions.raiseError(new Error(), msg ,caller, title);\n        }\n    }\n\n    export function assertFunction(value: any, msg = EMPTY_STR, caller=EMPTY_STR, title=\"Assertion Error\"): asserts value is Function {\n        assertType(value, \"function\", msg, caller, title);\n    }\n}\n\n\n","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {AsyncRunnable} from \"./AsyncRunnable\";\n\n/**\n * Asynchronous queue which starts to work\n * through the callbacks until the queue is empty\n *\n * Every callback must be of async runnable\n * which is sort of an extended promise which has\n * added a dedicated cancel and start point\n *\n * This interface can be used as wrapper contract\n * for normal promises if needed.\n */\nexport class AsynchronousQueue<T extends AsyncRunnable<any>> {\n\n    private runnableQueue = [];\n    private delayTimeout: null | ReturnType<typeof setTimeout>;\n\n    currentlyRunning: AsyncRunnable<any>;\n\n    constructor() {\n    }\n\n    /**\n     * simple is empty accessor, returns true if queue is empty atm\n     */\n    get isEmpty(): boolean {\n        return !this.runnableQueue.length;\n    }\n\n    /**\n     * enqueues an element and starts the\n     * asynchronous work loop if not already running\n     *\n     * @param element the element to be queued and processed\n     * @param delay possible delay after our usual process or drop if something newer is incoming algorithm\n     */\n    enqueue(element: T, delay = 0) {\n        if (this.delayTimeout) {\n            clearTimeout(this.delayTimeout);\n            this.delayTimeout = null;\n        }\n        if (delay) {\n            this.delayTimeout = setTimeout(() => {\n                this.appendElement(element);\n            });\n        } else {\n            this.appendElement(element);\n        }\n    }\n\n    /**\n     * fetches the next element from the queue (first in first out order)\n     */\n    dequeue(): T | undefined{\n        return this.runnableQueue.shift();\n    }\n\n    /**\n     * clears up all elements from the queue\n     */\n    cleanup() {\n        this.currentlyRunning = null;\n        this.runnableQueue.length = 0;\n    }\n\n    /**\n     * cancels the currently running element and then cleans up the queue\n     * aka cancel the queue entirely\n     */\n    cancel() {\n        try {\n            if (this.currentlyRunning) {\n                this.currentlyRunning.cancel();\n            }\n        } finally {\n            this.cleanup();\n        }\n    }\n\n    private callForNextElementToProcess() {\n        this.runEntry();\n    }\n\n    private appendElement(element: T) {\n        //only if the first element is added we start with a trigger\n        //otherwise a process already is running and not finished yet at that\n        //time\n        this.runnableQueue.push(element);\n        if (!this.currentlyRunning) {\n            this.runEntry();\n        }\n    }\n\n    private runEntry() {\n        if (this.isEmpty) {\n            this.currentlyRunning = null;\n            return;\n        }\n        this.currentlyRunning = this.dequeue();\n        this.currentlyRunning\n            .catch((e) => {\n                //in case of an error we always clean up the remaining calls\n                //to allow a clean recovery of the application\n                this.cleanup();\n                throw e;\n            })\n            .then(\n                //the idea is to trigger the next over an event to reduce\n                //the number of recursive calls (stacks might be limited\n                //compared to ram)\n                //naturally give we have a DOM, the DOM is the natural event dispatch system\n                //which we can use, to decouple the calls from a recursive stack call\n                //(the browser engine will take care of that)\n                () => this.callForNextElementToProcess()\n            ).start();\n    }\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Config, IValueHolder, Optional, DomQuery, DQ, Stream, ArrayCollector, Lang} from \"mona-dish\";\nimport {$nsp, P_WINDOW_ID} from \"../core/Const\";\nimport equalsIgnoreCase = Lang.equalsIgnoreCase;\nimport trim = Lang.trim;\n\n\n\n\n/**\n * detects whether a source is a faces.js request\n *\n * @param source the source string for the faces.js request\n * @return true if a faces.js loading pattern is detected\n * @constructor\n */\nconst IS_FACES_SOURCE = (source?: string): boolean => {\n    //spec version smaller 4 we have to deal with the jsf namespace\n\n    return source && !!(source?.search(/\\/jakarta\\.faces\\.resource.*\\/faces\\.js.*/) != -1 ||\n        source?.search(/\\/faces-development\\.js.*/) != -1 ||\n        source?.search(/\\/faces-uncompressed\\.js.*/) != -1 ||\n        source?.search(/\\/faces[^.]*\\.js.*ln=jakarta.faces.*/gi) != -1 ||\n        //fallback without check for jsf, that way we allow both bookmarks\n        source?.search(/\\/javax\\.faces\\.resource.*\\/jsf\\.js.*/) != -1 ||\n            source?.search(/\\/jsf-development\\.js.*/) != -1 ||\n            source?.search(/\\/jsf-uncompressed\\.js.*/) != -1 ||\n            source?.search(/\\/jsf[^.]*\\.js.*ln=javax.faces.*/gi) != -1);\n}\n\n/**\n * namespace myfaces.testscripts can be used as extension point for internal\n * tests, those will be handled similarly to faces.js regarding\n * reload blocking on ajax requests\n *\n * @param source the source to check\n * @constructor\n */\nconst IS_INTERNAL_SOURCE = (source: string): boolean => {\n    return source.search(/\\/faces[^.]*\\.js.*ln=myfaces.testscripts.*/gi) != -1 || source.search(/\\/jsf[^.]*\\.js.*ln=myfaces.testscripts.*/gi) != -1;\n}\n\n\nconst ATTR_SRC = 'src';\n\n/**\n * Extension which adds implementation specific\n * meta data to our dom query\n *\n * Usage\n * el = new ExtDQ(oldReference)\n * nonce = el.nonce\n * windowId = el.getWindowId\n */\nexport class ExtDomquery extends DQ {\n\n    static get windowId() {\n        return new ExtDomquery(document.body).windowId;\n    }\n\n    static get nonce(): string {\n        return new ExtDomquery(document.body).nonce;\n    }\n\n    get windowId(): string | null {\n\n        const fetchWindowIdFromURL = function (): string | null {\n            let href = window.location.href;\n            let windowId = \"windowId\";\n            let regex = new RegExp(\"[\\\\?&]\" + windowId + \"=([^&#\\\\;]*)\");\n            let results = regex.exec(href);\n            //initial trial over the url and a regexp\n            if (results != null) return results[1];\n            return null;\n        };\n\n        //byId ($)\n        if (this.value.isPresent()) {\n            let result = this.querySelectorAll(\"form input[name='\" + P_WINDOW_ID + \"']\");\n            if (result.length > 1) {\n                throw Error(\"Multiple different windowIds found in document\");\n            }\n\n            return (result.isPresent()) ? (<HTMLInputElement>result.getAsElem(0).value).value : fetchWindowIdFromURL();\n        } else {\n            return fetchWindowIdFromURL();\n        }\n    }\n\n    /*\n    * determines the faces.js nonce and adds them to the namespace\n    * this is done once and only lazily\n    */\n    get nonce(): string | null {\n        //already processed\n        let myfacesConfig = new ExtConfig(window.myfaces);\n        let nonce: IValueHolder<string> = myfacesConfig.getIf(\"config\", \"cspMeta\", \"nonce\");\n        if (nonce.value) {\n            return <string>nonce.value;\n        }\n\n        let curScript = new DQ(document.currentScript);\n        //since our baseline atm is ie11 we cannot use document.currentScript globally\n        if (!!this.extractNonce(curScript)) {\n            // fastpath for modern browsers\n            return this.extractNonce(curScript);\n        }\n        // fallback if the currentScript method fails, we just search the jsf tags for nonce, this is\n        // the last possibility\n        let nonceScript = DQ\n            .querySelectorAll(\"script[src], link[src]\")\n            .lazyStream\n            .filter((item) => this.extractNonce(item)  && item.attr(ATTR_SRC) != null)\n            .filter(item => IS_FACES_SOURCE(item.attr(ATTR_SRC).value))\n            .first();\n\n        if (nonceScript.isPresent()) {\n            return this.extractNonce(nonceScript.value);\n        }\n        return null;\n    }\n\n\n\n    private extractNonce(curScript: DomQuery) {\n        return (curScript.getAsElem(0).value as HTMLElement)?.nonce ?? curScript.attr(\"nonce\").value;\n    }\n\n    static searchJsfJsFor(item: RegExp): Optional<String> {\n        return new ExtDomquery(document).searchJsfJsFor(item);\n    }\n\n    /**\n     * searches the embedded faces.js for items like separator char etc..\n     * expects a match as variable under position 1 in the result match\n     * @param rexp\n     */\n    searchJsfJsFor(rexp: RegExp): Optional<string> {\n        //perfect application for lazy stream\n        return DQ.querySelectorAll(\"script[src], link[src]\").lazyStream\n            .filter(item => IS_FACES_SOURCE(item.attr(ATTR_SRC).value))\n            .map(item => item.attr(ATTR_SRC).value.match(rexp))\n            .filter(item => item != null && item.length > 1)\n            .map((result: string[]) => {\n                return decodeURIComponent(result[1]);\n            }).first();\n    }\n\n    globalEval(code: string, nonce ?: string): DQ {\n        return new ExtDomquery(super.globalEval(code, nonce ?? this.nonce));\n    }\n\n    globalEvalSticky(code: string, nonce ?: string): DQ {\n        return new ExtDomquery(super.globalEvalSticky(code, nonce ?? this.nonce));\n    }\n\n    /**\n     * decorated run scripts which takes our jsf extensions into consideration\n     * (standard DomQuery will let you pass anything)\n     * @param whilteListed\n     */\n    runScripts(sticky = false, whilteListed?: (src: string) => boolean): DomQuery {\n        const whitelistFunc = (src: string): boolean => {\n            return (whilteListed?.(src) ?? true) && !IS_FACES_SOURCE(src) && !IS_INTERNAL_SOURCE(src);\n        };\n        return super.runScripts(sticky, whitelistFunc);\n    }\n\n    /**\n     * adds the elements in this ExtDomQuery to the head\n     *\n     * @param newElements the elements which need addition\n     */\n    runHeadInserts(suppressDoubleIncludes = true): void {\n        let head = ExtDomquery.byId(document.head);\n        //automated nonce handling\n        let processedScripts = [];\n\n        // the idea is only to run head inserts on resources\n        // which do not exist already, that way\n        // we can avoid double includes on subsequent resource\n        // requests.\n        function resourceIsNew(element: DomQuery) {\n            if(!suppressDoubleIncludes) {\n                return true;\n            }\n            const tagName = element.tagName.value;\n            if(!tagName) {\n                // textnode\n                return true;\n            }\n            let href = element.attr(\"href\").orElse(element.attr(\"src\").value);\n\n            if (!href.isPresent()) {\n                return true;\n            }\n            return !head.querySelectorAll(`${tagName}[href='${href.value}']`).length &&\n                !head.querySelectorAll(`${tagName}[src='${href.value}']`).length;\n        }\n\n        this\n            .filter(resourceIsNew)\n            .each(element => {\n                if(element.tagName.value != \"SCRIPT\") {\n                    //we need to run runScripts properly to deal with the rest\n                    new ExtDomquery(...processedScripts).runScripts(true);\n                    processedScripts = [];\n                    head.append(element);\n                } else {\n                    processedScripts.push(element);\n                }\n            });\n        new ExtDomquery(...processedScripts).runScripts(true);\n    }\n\n\n    /**\n     * byId producer\n     *\n     * @param selector id\n     * @param deep whether the search should go into embedded shadow dom elements\n     * @return a DomQuery containing the found elements\n     */\n    static byId(selector: string | DomQuery | Element, deep = false): DomQuery {\n        const ret = DomQuery.byId(selector, deep);\n        return new ExtDomquery(ret);\n    }\n\n\n}\n\nexport const ExtDQ = ExtDomquery;\n\n/**\n * in order to reduce the number of interception points for the fallbacks we add\n * the namespace remapping straight to our config accessors\n */\nexport class ExtConfig extends  Config {\n\n    constructor(root: any) {\n        super(root);\n    }\n\n    assignIf(condition: boolean, ...accessPath): IValueHolder<any> {\n        const acessPathMapped = this.remap(accessPath);\n        return super.assignIf(condition, ...acessPathMapped);\n    }\n\n    assign(...accessPath): IValueHolder<any> {\n        const acessPathMapped = this.remap(accessPath);\n        return super.assign(...acessPathMapped);\n    }\n\n    append(...accessPath): IValueHolder<any> {\n        return super.append(...accessPath);\n    }\n\n    appendIf(condition: boolean, ...accessPath): IValueHolder<any> {\n        const acessPathMapped = this.remap(accessPath);\n        return super.appendIf(condition, ...acessPathMapped);\n    }\n\n    getIf(...accessPath): Config {\n        const acessPathMapped = this.remap(accessPath);\n        return super.getIf(...acessPathMapped);\n    }\n\n    get(defaultVal: any): Config {\n        return super.get($nsp(defaultVal));\n    }\n\n    delete(key: string): Config {\n        return super.delete($nsp(key));\n    }\n\n    /**\n     * creates a config from an initial value or null\n     * @param value\n     */\n    static fromNullable<T>(value?: T | null): Config {\n        return new ExtConfig(value);\n    }\n\n    protected getClass(): any {\n        return ExtConfig;\n    }\n\n    /**\n     * shallow copy getter, copies only the first level, references the deeper nodes\n     * in a shared manner\n     */\n    protected shallowCopy$(): Config {\n        const ret = super.shallowCopy$();\n        return new ExtConfig(ret);\n    }\n\n    /**\n     * deep copy, copies all config nodes\n     */\n    get deepCopy(): Config {\n        return new ExtConfig(super.deepCopy$());\n    }\n\n\n    private remap(accessPath: any[]) {\n        return Stream.of(...accessPath).map(key => $nsp(key)).collect(new ArrayCollector());\n    }\n\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * todo replace singleton with module definition\n *\n */\n\nimport {Lang as LangBase, Config, Optional, DomQuery, DQ, Stream} from \"mona-dish\";\nimport {Messages} from \"../i18n/Messages\";\nimport {EMPTY_STR, TAG_FORM} from \"../core/Const\";\nimport {getEventTarget} from \"../xhrCore/RequestDataResolver\";\n\n\nexport module ExtLang {\n\n    let installedLocale: Messages;\n    let nameSpace = \"impl/util/Lang/\";\n\n    export function getLanguage(): string {\n        //TODO global config override\n\n        let language: string = (<any>navigator).languages?.[0] ?? navigator?.language;\n        language = language.split(\"-\")[0];\n        return language;\n    }\n\n    //should be in lang, but for now here to avoid recursive imports, not sure if typescript still has a problem with those\n    /**\n     * helper function to savely resolve anything\n     * this is not an elvis operator, it resolves\n     * a value without exception in a tree and if\n     * it is not resolvable then an optional of\n     * a default value is restored or Optional.empty\n     * if none is given\n     *\n     * usage\n     * <code>\n     *     let var: Optional<string> = saveResolve(() => a.b.c.d.e, \"foobaz\")\n     * </code>\n     *\n     * @param resolverProducer a lambda which can produce the value\n     * @param defaultValue an optional default value if the producer failes to produce anything\n     * @returns an Optional of the produced value\n     */\n    export function failSaveResolve<T>(resolverProducer: () => T, defaultValue: T = null): Optional<T> {\n        return LangBase.saveResolve(resolverProducer, defaultValue);\n    }\n\n    /**\n     * under some conditions it makes sense to swallow errors and return a default value in the error case\n     * classical example the optional resolution of values in a chain (thankfully now covered by Typescript itself)\n     * another example which we have in our system is that some operations fail only under test due to test framework\n     * limitations while they cannot fail in the real world.\n     *\n     * @param resolverProducer a producer function which produces a value in the non error case\n     * @param defaultValue the default value in case of a fail of the function\n     */\n    export function failSaveExecute<T>(resolverProducer: () => any, defaultValue: T = null): void {\n        LangBase.saveResolve(resolverProducer, defaultValue);\n    }\n\n    /**\n     * returns a given localized message upon a given key\n     * basic java log like templating functionality is included\n     *\n     * @param {String} key the key for the message\n     * @param {String} defaultMessage optional default message if none was found\n     *\n     * Additionally you can pass additional arguments, which are used\n     * in the same way java log templates use the params\n     *\n     * @param templateParams the param list to be filled in\n     */\n    export function getMessage(key: string, defaultMessage?: string, ...templateParams: Array<string>): string {\n        installedLocale = installedLocale ?? new Messages();\n\n        let msg = installedLocale[key] ?? defaultMessage ?? key;\n\n        Stream.of(...templateParams).each((param, cnt) => {\n            msg = msg.replace(new RegExp([\"\\\\{\", cnt, \"\\\\}\"].join(EMPTY_STR), \"g\"), param);\n        });\n\n        return msg;\n    }\n\n    /**\n     * transforms a key value pair into a string\n     * @param key the key\n     * @param val the value\n     * @param delimiter the delimiter\n     */\n    export function keyValToStr(key: string, val: string, delimiter: string = \"\\n\") {\n        return [key, val].join(delimiter);\n    }\n\n    /**\n     * creates an exeption with additional internal parameters\n     * for extra information\n     *\n     * @param error\n     * @param {String} title the exception title\n     * @param {String} name  the exception name\n     * @param {String} callerCls the caller class\n     * @param {String} callFunc the caller function\n     * @param {String} message the message for the exception\n     */\n    export function makeException(error: Error, title: string, name: string, callerCls: string, callFunc: string, message: string): Error {\n\n        return new Error(message + (callerCls ?? nameSpace) + callFunc ?? (EMPTY_STR + (<any>arguments).caller.toString()));\n\n    }\n\n    /**\n     * fetches a global config entry\n     * @param {String} configName the name of the configuration entry\n     * @param {Object} defaultValue\n     *\n     * @return either the config entry or if none is given the default value\n     */\n    export function getGlobalConfig(configName: string, defaultValue: any): any {\n        /**\n         * note we could use exists but this is an heavy operation, since the config name usually\n         * given this function here is called very often\n         * is a single entry without . in between we can do the lighter shortcut\n         */\n        return window?.myfaces?.config?.[configName] ?? defaultValue;\n    }\n\n    /**\n     * fetches the form in an fuzzy manner depending\n     * on an element or event target.\n     *\n     * The idea is that according to the jsf spec\n     * the enclosing form of the issuing element needs to be fetched.\n     *\n     * This is fine, but since then html5 came into the picture with the form attribute the element\n     * can be anywhere referencing its parent form.\n     *\n     * Also theoretically you can have the case of an issuing element enclosing a set of forms\n     * (not really often used, but theoretically it could be input button allows to embed html for instance)\n     *\n     * So the idea is not to limit the issuing form determination to the spec case\n     * but also cover the theoretical and html5 corner case.\n     *\n     * @param elem\n     * @param event\n     */\n    export function getForm(elem: Element, event ?: Event): DQ | never {\n\n        let queryElem = new DQ(elem);\n        let eventTarget = new DQ(getEventTarget(event));\n\n        if (queryElem.isTag(TAG_FORM)) {\n            return queryElem;\n        }\n\n        //html 5 for handling\n        if (queryElem.attr(TAG_FORM).isPresent()) {\n            let formId = queryElem.attr(TAG_FORM).value;\n            let foundForm = DQ.byId(formId, true);\n            if (foundForm.isPresent()) {\n                return foundForm;\n            }\n        }\n\n        let form = queryElem.parents(TAG_FORM)\n            .orElseLazy(() => queryElem.byTagName(TAG_FORM, true))\n            .orElseLazy(() => eventTarget.parents(TAG_FORM))\n            .orElseLazy(() => eventTarget.byTagName(TAG_FORM))\n            .first();\n\n        assertFormExists(form);\n\n        return form;\n    }\n\n    /**\n     * gets the local or global options with local ones having higher priority\n     * if no local or global one was found then the default value is given back\n     *\n     * @param {String} configName the name of the configuration entry\n     * @param {String} localOptions the local options root for the configuration myfaces as default marker is added implicitely\n     *\n     * @param {Object} defaultValue\n     *\n     * @return either the config entry or if none is given the default value\n     */\n    export function getLocalOrGlobalConfig(localOptions: Config, configName: string, defaultValue: any): any {\n        return localOptions.value?.myfaces?.config?.[configName] ??\n            window?.myfaces?.config?.[configName] ??\n            defaultValue;\n    }\n\n    /**\n     * assert that the form exists and throw an exception in the case it does not\n     *\n     * @param form the form to check for\n     */\n    function assertFormExists(form: DomQuery): void | never {\n        if (form.isAbsent()) {\n            throw makeException(new Error(), null, null, \"Impl\", \"getForm\", getMessage(\"ERR_FORM\"));\n        }\n    }\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n    EMPTY_STR,\n    ERROR_MESSAGE,\n    ERROR_NAME,\n    RESPONSE_TEXT,\n    RESPONSE_XML,\n    SOURCE,\n    STATUS,\n    UNKNOWN\n} from \"../core/Const\";\nimport {Config} from \"mona-dish\";\n\nimport {EventData} from \"./EventData\";\nimport {ExtLang} from \"../util/Lang\";\nimport getMessage = ExtLang.getMessage;\n\n\nexport enum ErrorType {\n    SERVER_ERROR = \"serverError\",\n    HTTP_ERROR = \"httpError\",\n    CLIENT_ERROR = \"clientErrror\",\n    TIMEOUT = \"timeout\"\n}\n\n/**\n * the spec has a problem of having the error\n * object somewhat underspecified, there is no clear\n * description of the required contents.\n * I want to streamline it with mojarra here\n * hence we are going to move\n * everything into the same attributes,\n * I will add deprecated myfaces backwards compatibility attributes as well\n */\nexport class ErrorData extends EventData implements IErrorData {\n\n    type: string = \"error\";\n    source: string;\n    errorName: string;\n    errorMessage: string;\n\n    responseText: string;\n    responseXML: any;\n\n    status: string;\n    typeDetails: ErrorType;\n\n    serverErrorName: string;\n    serverErrorMessage: string;\n    message: string;\n\n    constructor(source: string, errorName: string, errorMessage: string, responseText: string = null, responseXML: any = null, responseCode: string = \"200\", status: string = \"UNKNOWN\", type = ErrorType.CLIENT_ERROR) {\n        super();\n        this.source = source;\n        this.type = \"error\";\n        this.errorName = errorName;\n        this.message = this.errorMessage = errorMessage;\n        this.responseCode = responseCode;\n        this.responseText = responseText;\n        this.status = status;\n        this.typeDetails = type;\n\n        if (type == ErrorType.SERVER_ERROR) {\n            this.serverErrorName = this.errorName;\n            this.serverErrorMessage = this.errorMessage;\n        }\n    }\n\n    static fromClient(e: Error): ErrorData {\n        return new ErrorData(\"client\", e?.name ?? '', e?.message ?? '', e?.stack ?? '');\n    }\n\n    static fromHttpConnection(source: any, name: string, message: string, responseText, responseCode: number, status: string = 'UNKNOWN'): ErrorData {\n        return new ErrorData(source, name, message, responseText, responseCode, `${responseCode}`, status, ErrorType.HTTP_ERROR);\n    }\n\n    static fromGeneric(context: Config, errorCode: number, errorType: ErrorType = ErrorType.SERVER_ERROR): ErrorData {\n\n        let getMsg = this.getMsg;\n\n        let source = getMsg(context, SOURCE);\n        let errorName = getMsg(context, ERROR_NAME);\n        let errorMessage = getMsg(context, ERROR_MESSAGE);\n        let status = getMsg(context, STATUS);\n        let responseText = getMsg(context, RESPONSE_TEXT);\n        let responseXML = getMsg(context, RESPONSE_XML);\n        return new ErrorData(source, errorName, errorMessage, responseText, responseXML, errorCode + EMPTY_STR, status, errorType);\n    }\n\n    private static getMsg(context, param) {\n        return getMessage(context.getIf(param).orElse(UNKNOWN).value);\n    }\n\n    static fromServerError(context: Config): ErrorData {\n        return this.fromGeneric(context, -1);\n    }\n\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Config, DQ} from \"mona-dish\";\nimport {BEGIN, CTX_PARAM_PASS_THR, EVENT, P_PARTIAL_SOURCE, SOURCE} from \"../core/Const\";\n\nexport class EventData implements IEventData{\n    type: string;\n    status: string;\n    source: any;\n    responseCode: string;\n    responseText: string;\n    responseXML: Document;\n\n    static createFromRequest(request: XMLHttpRequest, context: Config, /*event name*/ name: string): EventData {\n\n        let eventData = new EventData();\n\n        eventData.type = EVENT;\n        eventData.status = name;\n\n        let sourceId: string = context.getIf(SOURCE)\n            .orElseLazy(() => context.getIf(P_PARTIAL_SOURCE).value)\n            .orElseLazy(() => context.getIf(CTX_PARAM_PASS_THR, P_PARTIAL_SOURCE).value)\n            .value;\n        if (sourceId) {\n            eventData.source = DQ.byId(sourceId, true).first().value.value;\n        }\n\n        if (name !== BEGIN) {\n            eventData.responseCode = request?.status?.toString();\n            eventData.responseText = request?.responseText;\n            eventData.responseXML = request?.responseXML;\n        }\n        return eventData;\n    }\n}\n","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Config, DomQuery, DQ} from \"mona-dish\";\nimport {\n    CTX_PARAM_DELAY,\n    CTX_PARAM_TIMEOUT,\n    EMPTY_FUNC,\n    EMPTY_STR,\n    ENCODED_URL,\n    MF_NONE,\n    REQ_TYPE_GET,\n    REQ_TYPE_POST\n} from \"../core/Const\";\nimport {XhrFormData} from \"./XhrFormData\";\nimport {ExtLang} from \"../util/Lang\";\nimport {ExtConfig, ExtDomquery} from \"../util/ExtDomQuery\";\n\n/**\n * Resolver functions for various aspects of the request data\n *\n * stateless because it might be called from various\n * parts of the response classes\n */\n\n/**\n * resolves the event handlers lazly\n * so that if some decoration happens in between we can deal with it\n *\n * @param requestContext\n * @param responseContext\n * @param funcName\n */\nexport function resolveHandlerFunc(requestContext: Config, responseContext: Config, funcName: string) {\n    return responseContext.getIf(funcName)\n        .orElseLazy(() =>requestContext.getIf(funcName).value)\n        .orElse(EMPTY_FUNC).value;\n}\n\nexport function resolveTargetUrl(srcFormElement: HTMLFormElement) {\n    return (typeof srcFormElement.elements[ENCODED_URL] == 'undefined') ?\n        srcFormElement.action :\n        srcFormElement.elements[ENCODED_URL].value;\n}\n\nexport function resolveFinalUrl(sourceForm: DomQuery, formData: XhrFormData, ajaxType = REQ_TYPE_POST) {\n    let targetUrl = resolveTargetUrl(<HTMLFormElement>sourceForm.getAsElem(0).value);\n\n    return targetUrl + (ajaxType == REQ_TYPE_GET ? \"?\" + formData.toString() : EMPTY_STR);\n}\n\n/**\n * form resolution the same way our old implementation did\n * it is either the id or the parent form of the element or an embedded form\n * of the element\n *\n * @param requestCtx\n * @param elem\n * @param event\n */\nexport function resolveForm(requestCtx: Config, elem: DQ, event: Event): DQ {\n    const configId = requestCtx.value?.myfaces?.form ?? MF_NONE;\n    return DQ\n        .byId(configId, true)\n        .orElseLazy(() => ExtLang.getForm(elem.getAsElem(0).value, event));\n}\n\nexport function resolveTimeout(options: Config): number {\n    let getCfg = ExtLang.getLocalOrGlobalConfig;\n    return options.getIf(CTX_PARAM_TIMEOUT).value ?? getCfg(options.value, CTX_PARAM_TIMEOUT, 0);\n}\n\n/**\n * resolve the delay from the options and/or the request context and or the configuration\n *\n * @param options ... the options object, in most cases it will host the delay value\n */\nexport function resolveDelay(options: Config): number {\n    let getCfg = ExtLang.getLocalOrGlobalConfig;\n\n    return options.getIf(CTX_PARAM_DELAY).value ?? getCfg(options.value, CTX_PARAM_DELAY, 0);\n}\n\n/**\n * resolves the window Id from various sources\n *\n * @param options\n */\nexport function resolveWindowId(options: Config) {\n    return options?.value?.windowId ?? ExtDomquery.windowId;\n}\n\n/**\n * cross port from the dojo lib\n * browser save event resolution\n * @param evt the event object\n * (with a fallback for ie events if none is present)\n */\nexport function getEventTarget(evt: Event): Element {\n    //ie6 and 7 fallback\n    let finalEvent = evt;\n    /**\n     * evt source is defined in the jsf events\n     * seems like some component authors use our code\n     * so we add it here see also\n     * https://issues.apache.org/jira/browse/MYFACES-2458\n     * not entirely a bug but makes sense to add this\n     * behavior. I dont use it that way but nevertheless it\n     * does not break anything so why not\n     * */\n    let t = finalEvent?.srcElement ?? finalEvent?.target ?? (<any>finalEvent)?.source;\n    while ((t) && (t.nodeType != 1)) {\n        t = t.parentNode;\n    }\n    return t;\n}\n\n/**\n * resolves a bunch of default values\n * which can be further processed from the given\n * call parameters of faces.ajax.request\n *\n * @param event\n * @param opts\n * @param el\n */\nexport function resolveDefaults(event: Event, opts: any = {}, el: Element | string = null) {\n    //deep copy the options, so that further transformations to not backfire into the callers\n    const resolvedEvent = event,\n        options = new ExtConfig(opts).deepCopy,\n        elem = DQ.byId(el || <Element>resolvedEvent.target, true),\n        elementId = elem.id.value, requestCtx = new ExtConfig({}),\n        internalCtx = new ExtConfig({}), windowId = resolveWindowId(options),\n        isResetValues = true === options.value?.resetValues;\n\n    return {resolvedEvent, options, elem, elementId, requestCtx, internalCtx, windowId, isResetValues};\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Config, Optional, XMLQuery} from \"mona-dish\";\n\nimport {Assertions} from \"../util/Assertions\";\nimport {DQ} from \"mona-dish\";\nimport {\n    $nsp,\n    CTX_PARAM_MF_INTERNAL,\n    CTX_PARAM_SRC_CTL_ID,\n    CTX_PARAM_SRC_FRM_ID,\n    SEL_RESPONSE_XML,\n    SOURCE,\n    TAG_FORM,\n    UPDATE_ELEMS,\n    UPDATE_FORMS,\n    DEFERRED_HEAD_INSERTS\n} from \"../core/Const\";\nimport {ExtConfig} from \"../util/ExtDomQuery\";\n\n/**\n * Resolver functions for various aspects of the response data\n *\n * stateless because it might be called from various\n * parts of the response classes\n */\n\n/**\n * fetches the response XML\n * as XML Query object\n *\n * @param request the request hosting the responseXML\n *\n * Throws an error in case of non existent or wrong xml data\n *\n */\nexport function resolveResponseXML(request: Config): XMLQuery {\n    let ret = new XMLQuery($nsp(request.getIf(SEL_RESPONSE_XML).value));\n    Assertions.assertValidXMLResponse(ret);\n\n    return ret;\n}\n\n/**\n * Splits the incoming passthrough context apart\n * in an internal and an external nomalized context\n * the internal one is just for our internal processing\n *\n * @param context the root context as associative array\n */\nexport function resolveContexts(context: { [p: string]: any }): any {\n    /**\n     * we split the context apart into the external one and\n     * some internal values\n     */\n    let externalContext = ExtConfig.fromNullable(context);\n    let internalContext = externalContext.getIf(CTX_PARAM_MF_INTERNAL);\n    if (!internalContext.isPresent()) {\n        internalContext = ExtConfig.fromNullable({});\n    }\n\n    /**\n     * prepare storage for some deferred operations\n     */\n    internalContext.assign(DEFERRED_HEAD_INSERTS).value = [];\n    internalContext.assign(UPDATE_FORMS).value = [];\n    internalContext.assign(UPDATE_ELEMS).value = [];\n    return {externalContext, internalContext};\n}\n\n/**\n * fetches the source element out of our conexts\n *\n * @param context the external context which shpuld host the source id\n * @param internalContext internal passthrough fall back\n *\n */\nexport function resolveSourceElement(context: Config, internalContext: Config): DQ {\n    let elemId = resolveSourceElementId(context, internalContext);\n    return DQ.byId(elemId.value, true);\n}\n\n/**\n * fetches the source form if it still exists\n * also embedded forms and parent forms are taken into consideration\n * as fallbacks\n *\n * @param internalContext\n * @param elem\n */\nexport function resolveSourceForm(internalContext: Config, elem: DQ): DQ {\n    let sourceFormId = internalContext.getIf(CTX_PARAM_SRC_FRM_ID);\n    let sourceForm = new DQ(sourceFormId.isPresent() ? document.forms[sourceFormId.value] : null);\n\n    sourceForm = sourceForm.orElseLazy(() => elem.parents(TAG_FORM))\n        .orElseLazy(() => elem.querySelectorAll(TAG_FORM))\n        .orElseLazy(() => DQ.querySelectorAll(TAG_FORM));\n\n    return sourceForm;\n}\n\nfunction resolveSourceElementId(context: Config, internalContext: Config): Optional<string> {\n    //?internal context?? used to be external one\n    return internalContext.getIf(CTX_PARAM_SRC_CTL_ID)\n        .orElseLazy(() => context.getIf(SOURCE, \"id\").value);\n}\n\n","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {DQ, XMLQuery} from \"mona-dish\";\nimport {ResponseProcessor} from \"./ResponseProcessor\";\n\nimport {IResponseProcessor} from \"./IResponseProcessor\";\nimport {\n    $nsp,\n    CMD_ATTRIBUTES,\n    CMD_CHANGES,\n    CMD_DELETE,\n    CMD_ERROR,\n    CMD_EVAL,\n    CMD_EXTENSION,\n    CMD_INSERT,\n    CMD_REDIRECT,\n    CMD_UPDATE, P_RESOURCE,\n    P_VIEWBODY,\n    P_VIEWHEAD,\n    P_VIEWROOT,\n    PARTIAL_ID,\n    RESP_PARTIAL,\n    RESPONSE_XML,\n    TAG_AFTER,\n    TAG_BEFORE\n} from \"../core/Const\";\nimport {resolveContexts, resolveResponseXML} from \"./ResonseDataResolver\";\nimport {ExtConfig} from \"../util/ExtDomQuery\";\n\n\n\nexport module Response {\n\n\n    /**\n     * Standardized faces.ts response\n     * this one is called straight from faces.ts.response\n     *\n     * The processing follows the spec by going for the responseXML\n     * and processing its tags\n     *\n     * @param {XMLHttpRequest} request (xhrRequest) - xhr request object\n     * @param context {Context} context (Map) - AJAX context\n     *\n     */\n    export function processResponse(request: XMLHttpRequest, context: Context) {\n\n        let req = ExtConfig.fromNullable(request);\n        let {externalContext, internalContext} = resolveContexts(context);\n        let responseXML: XMLQuery = resolveResponseXML(req);\n        let responseProcessor = new ResponseProcessor(req, externalContext, internalContext);\n\n        internalContext.assign(RESPONSE_XML).value = responseXML;\n\n        //we now process the partial tags, or in none given raise an error\n        responseXML.querySelectorAll(RESP_PARTIAL)\n            .each(item => processPartialTag(<XMLQuery>item, responseProcessor, internalContext));\n\n        //we now process the viewstates, client windows and the evals deferred\n        //the reason for this is that often it is better\n        //to wait until the document has caught up before\n        //doing any evals even on embedded scripts\n        //usually this does not matter, the client window comes in almost last always anyway\n        //we maybe drop this deferred assignment in the future, but myfaces did it until now\n        responseProcessor.fixViewStates();\n        responseProcessor.fixClientWindow();\n        responseProcessor.globalEval();\n\n        responseProcessor.done();\n    }\n\n    /**\n     * highest node partial-response from there the main operations are triggered\n     */\n     function processPartialTag(node: XMLQuery, responseProcessor: IResponseProcessor, internalContext) {\n\n        internalContext.assign(PARTIAL_ID).value = node.id;\n        const SEL_SUB_TAGS = [CMD_ERROR, CMD_REDIRECT, CMD_CHANGES].join(\",\");\n\n        //now we can process the main operations\n        node.querySelectorAll(SEL_SUB_TAGS).each((node: XMLQuery) => {\n            switch (node.tagName.value) {\n                case CMD_ERROR:\n                    responseProcessor.error(node);\n                    break;\n                case CMD_REDIRECT:\n                    responseProcessor.redirect(node);\n                    break;\n                case CMD_CHANGES:\n                    processChangesTag(node, responseProcessor);\n                    break;\n            }\n        });\n\n    }\n\n    let processInsert = function (responseProcessor: IResponseProcessor, node: XMLQuery) {\n         //path1 insert after as child tags\n         if(node.querySelectorAll([TAG_BEFORE, TAG_AFTER].join(\",\")).length) {\n             responseProcessor.insertWithSubtags(node);\n         } else { //insert before after with id\n             responseProcessor.insert(node);\n         }\n\n    };\n\n    /**\n     * next level changes tag\n     *\n     * @param node\n     * @param responseProcessor\n     */\n     function processChangesTag(node: XMLQuery, responseProcessor: IResponseProcessor): boolean {\n        const ALLOWED_TAGS = [CMD_UPDATE, CMD_EVAL, CMD_INSERT, CMD_DELETE, CMD_ATTRIBUTES, CMD_EXTENSION].join(\", \");\n        node.querySelectorAll(ALLOWED_TAGS).each(\n            (node: XMLQuery) => {\n                switch (node.tagName.value) {\n                    case CMD_UPDATE:\n                        processUpdateTag(node, responseProcessor);\n                        break;\n\n                    case CMD_EVAL:\n                        responseProcessor.eval(node);\n                        break;\n\n                    case CMD_INSERT:\n                        processInsert(responseProcessor, node);\n                        break;\n\n                    case CMD_DELETE:\n                        responseProcessor.delete(node);\n                        break;\n\n                    case CMD_ATTRIBUTES:\n                        responseProcessor.attributes(node);\n                        break;\n\n                    case CMD_EXTENSION:\n                        break;\n                }\n            }\n        );\n        return true;\n    }\n\n    /**\n     * checks and stores a state update for delayed processing\n     *\n     * @param responseProcessor the response processor to perform the store operation\n     * @param node the xml node to check for the state\n     *\n     * @private\n     */\n    function storeState(responseProcessor: IResponseProcessor, node: XMLQuery) {\n        return responseProcessor.processViewState(node) || responseProcessor.processClientWindow(node);\n    }\n\n    /**\n     * branch tag update. drill further down into the updates\n     * special case viewstate in that case it is a leaf\n     * and the viewstate must be processed\n     *\n     * @param node\n     * @param responseProcessor\n     */\n     function processUpdateTag(node: XMLQuery, responseProcessor: IResponseProcessor) {\n         //early state storing, if no state we perform a normal update cycle\n        if (!storeState(responseProcessor, node)) {\n            handleElementUpdate(node, responseProcessor);\n        }\n    }\n\n    /**\n     * element update\n     *\n     * @param node\n     * @param responseProcessor\n     */\n     function handleElementUpdate(node: XMLQuery, responseProcessor: IResponseProcessor) {\n        let cdataBlock = node.cDATAAsString;\n        switch (node.id.value) {\n            case $nsp(P_VIEWROOT) :\n                responseProcessor.replaceViewRoot(DQ.fromMarkup(cdataBlock.substring(cdataBlock.indexOf(\"<html\"))));\n                break;\n\n            case $nsp(P_VIEWHEAD):\n                responseProcessor.replaceHead(DQ.fromMarkup(cdataBlock));\n                break;\n\n            case $nsp(P_VIEWBODY):\n                responseProcessor.replaceBody(DQ.fromMarkup(cdataBlock));\n                break;\n\n            case $nsp(P_RESOURCE):\n                responseProcessor.addToHead(DQ.fromMarkup(cdataBlock))\n                break;\n\n            default://htmlItem replacement\n                responseProcessor.update(node, cdataBlock);\n                break;\n        }\n    }\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Config, DomQuery, DQ, Lang, Stream, XMLQuery} from \"mona-dish\";\nimport {Implementation} from \"../AjaxImpl\";\nimport {Assertions} from \"../util/Assertions\";\nimport {IResponseProcessor} from \"./IResponseProcessor\";\nimport {ErrorData} from \"./ErrorData\";\nimport {StateHolder} from \"../core/ImplTypes\";\nimport {EventData} from \"./EventData\";\n\nimport {\n    $nsp,\n    APPLIED_CLIENT_WINDOW,\n    APPLIED_VST,\n    ATTR_ID,\n    ATTR_NAME,\n    ATTR_URL,\n    ATTR_VALUE,\n    EMPTY_FUNC,\n    EMPTY_STR,\n    ERROR_MESSAGE,\n    ERROR_NAME,\n    HTML_VIEWSTATE,\n    ON_ERROR,\n    ON_EVENT, P_CLIENT_WINDOW,\n    P_PARTIAL_SOURCE,\n    P_VIEWSTATE,\n    RESPONSE_XML, SEL_CLIENT_WINDOW_ELEM,\n    SEL_SCRIPTS_STYLES,\n    SEL_VIEWSTATE_ELEM,\n    SOURCE,\n    SUCCESS,\n    TAG_AFTER,\n    TAG_ATTR,\n    TAG_BEFORE,\n    TAG_BODY,\n    TAG_FORM,\n    TAG_HEAD,\n    UPDATE_ELEMS,\n    UPDATE_FORMS,\n    DEFERRED_HEAD_INSERTS\n} from \"../core/Const\";\nimport trim = Lang.trim;\nimport {ExtConfig, ExtDomquery} from \"../util/ExtDomQuery\";\n\n\n/**\n * Response processor\n *\n * Each  XML tag is either a node or a leaf\n * or both\n *\n * the processor provides a set of operations\n * which are executed on a single leaf node per operation\n * and present the core functionality of our response\n *\n * Note the response processor is stateful hence we bundle it in a class\n * to reduce code we keep references tot contexts in place\n */\nexport class ResponseProcessor implements IResponseProcessor {\n\n    constructor(private request: Config, private externalContext: Config, private internalContext: Config) {\n    }\n\n    /**\n     * head replacement\n     * @param shadowDocument incoming shadow head data (aka cdata as xml reference or dom element)\n     * the data incoming must represent the html representation of the head itself one way or the other\n     */\n    replaceHead(shadowDocument: XMLQuery | DQ) {\n        let shadowHead = shadowDocument.querySelectorAll(TAG_HEAD);\n        if (!shadowHead.isPresent()) {\n            return;\n        }\n\n        let oldHead = ExtDomquery.querySelectorAll(TAG_HEAD);\n\n        //delete all to avoid script and style overlays\n        oldHead.querySelectorAll(SEL_SCRIPTS_STYLES).delete();\n\n        // we cannot replace new elements in the head, but we can eval the elements\n        // eval means the scripts will get attached (eval script attach method)\n        // but this is done by DomQuery not in this code\n        this.storeForEval(shadowHead);\n        //incoming either the outer head tag or its childs\n        //shadowHead = (shadowHead.tagName.value === \"HEAD\") ? shadowHead.childNodes : shadowHead;\n        //this.addToHead(shadowHead);\n    }\n\n    addToHead(newElements: XMLQuery | DQ) {\n        this.internalContext.assign(DEFERRED_HEAD_INSERTS).value.push(newElements);\n    }\n\n\n\n    /**\n     * replaces the body in the expected manner\n     * which means the entire body content is refreshed\n     * however also the body attributes must be transferred\n     * keeping event handlers etc... in place\n     *\n     * @param shadowDocument .. an incoming shadow document hosting the new nodes\n     */\n    replaceBody(shadowDocument: XMLQuery | DQ) {\n\n        let shadowBody = shadowDocument.querySelectorAll(TAG_BODY);\n        if (!shadowBody.isPresent()) {\n            return;\n        }\n\n        let shadowInnerHTML: string = <string>shadowBody.html().value;\n\n        let resultingBody = <DQ>ExtDomquery.querySelectorAll(TAG_BODY).html(shadowInnerHTML);\n        let updateForms = resultingBody.querySelectorAll(TAG_FORM);\n\n        // main difference, we cannot replace the body itself, but only its content\n        // we need a separate step for post processing the incoming attributes, like classes, styles etc...\n        resultingBody.copyAttrs(shadowBody);\n\n        this.storeForPostProcessing(updateForms, resultingBody);\n    }\n\n    /**\n     * Leaf Tag eval... process whatever is in the evals cdata block\n     *\n     * @param node the node to eval\n     */\n    eval(node: XMLQuery) {\n        ExtDomquery.globalEval(node.cDATAAsString);\n    }\n\n    /**\n     * processes an incoming error from the response\n     * which is hosted under the &lt;error&gt; tag\n     * @param node the node hosting the error in our response xml\n     * @param node the node in the xml hosting the error message\n     */\n    error(node: XMLQuery) {\n        /**\n         * <error>\n         *      <error-name>String</error-name>\n         *      <error-message><![CDATA[message]]></error-message>\n         * <error>\n         */\n\n        let mergedErrorData = new ExtConfig({});\n        mergedErrorData.assign(SOURCE).value = this.externalContext.getIf(P_PARTIAL_SOURCE).get(0).value;\n        mergedErrorData.assign(ERROR_NAME).value = node.querySelectorAll(ERROR_NAME).textContent(EMPTY_STR);\n        mergedErrorData.assign(ERROR_MESSAGE).value = node.querySelectorAll(ERROR_MESSAGE).cDATAAsString;\n\n        let hasResponseXML = this.internalContext.get(RESPONSE_XML).isPresent();\n\n        //we now store the response xml also in the error data for further details\n        mergedErrorData.assignIf(hasResponseXML, RESPONSE_XML).value = this.internalContext.getIf(RESPONSE_XML).value.get(0).value;\n\n        // error post processing and enrichment (standard messages from keys)\n        let errorData = ErrorData.fromServerError(mergedErrorData);\n\n        // we now trigger an internally stored onError function which might be a attached to the context\n        // either we haven an internal on error, or an on error has been bassed via params from the outside\n        // in both cases they are attached to our contexts\n\n        this.triggerOnError(errorData);\n        Implementation.sendError(errorData);\n    }\n\n    /**\n     * process the redirect operation\n     *\n     * @param node\n     */\n    redirect(node: XMLQuery) {\n        Assertions.assertUrlExists(node);\n\n        let redirectUrl = trim(node.attr(ATTR_URL).value);\n        if (redirectUrl != EMPTY_STR) {\n            window.location.href = redirectUrl;\n        }\n    }\n\n    /**\n     * processes the update operation and updates the node with the cdata block\n     * @param node the xml response node hosting the update info\n     * @param cdataBlock the cdata block with the new html code\n     */\n    update(node: XMLQuery, cdataBlock: string) {\n        let result = ExtDomquery.byId(node.id.value, true).outerHTML(cdataBlock, false, false);\n        let sourceForm = result?.parents(TAG_FORM).orElseLazy(() => result.byTagName(TAG_FORM, true));\n        if (sourceForm) {\n            this.storeForPostProcessing(sourceForm, result);\n        }\n    }\n\n    /**\n     * Delete handler, simply deleetes the node referenced by the xml data\n     * @param node\n     */\n    delete(node: XMLQuery) {\n        DQ.byId(node.id.value, true).delete();\n    }\n\n    /**\n     * attributes leaf tag... process the attributes\n     *\n     * @param node\n     */\n    attributes(node: XMLQuery) {\n        let elem = DQ.byId(node.id.value, true);\n\n        node.byTagName(TAG_ATTR).each((item: XMLQuery) => {\n            elem.attr(item.attr(ATTR_NAME).value).value = item.attr(ATTR_VALUE).value;\n        });\n    }\n\n    /**\n     * @param shadowDocument a shadow document which is needed for further processing\n     */\n    replaceViewRoot(shadowDocument: XMLQuery) {\n        this.replaceHead(shadowDocument);\n        this.replaceBody(shadowDocument);\n    }\n\n    /**\n     * Insert handling, either before or after\n     *\n     * @param node\n     */\n    insert(node: XMLQuery) {\n        //let insertId = node.id; //not used atm\n\n        let before = node.attr(TAG_BEFORE);\n        let after = node.attr(TAG_AFTER);\n\n        let insertNodes = DQ.fromMarkup(<any>node.cDATAAsString);\n\n        if (before.isPresent()) {\n            DQ.byId(before.value, true).insertBefore(insertNodes);\n            this.internalContext.assign(UPDATE_ELEMS).value.push(insertNodes);\n        }\n        if (after.isPresent()) {\n            let domQuery = DQ.byId(after.value, true);\n            domQuery.insertAfter(insertNodes);\n\n            this.internalContext.assign(UPDATE_ELEMS).value.push(insertNodes);\n        }\n    }\n\n    /**\n     * Handler for the case &lt;insert <&lt; before id=\"...\n     *\n     * @param node the node hosting the insert data\n     */\n    insertWithSubtags(node: XMLQuery) {\n        let before = node.querySelectorAll(TAG_BEFORE);\n        let after = node.querySelectorAll(TAG_AFTER);\n\n        before.each(item => {\n            let insertId = item.attr(ATTR_ID);\n            let insertNodes = DQ.fromMarkup(<any>item.cDATAAsString);\n            if (insertId.isPresent()) {\n                DQ.byId(insertId.value, true).insertBefore(insertNodes);\n                this.internalContext.assign(UPDATE_ELEMS).value.push(insertNodes);\n            }\n        });\n\n        after.each(item => {\n            let insertId = item.attr(ATTR_ID);\n            let insertNodes = DQ.fromMarkup(<any>item.cDATAAsString);\n            if (insertId.isPresent()) {\n                DQ.byId(insertId.value, true).insertAfter(insertNodes);\n                this.internalContext.assign(UPDATE_ELEMS).value.push(insertNodes);\n            }\n        });\n    }\n\n    /**\n     * Process the viewState update, update the affected\n     * forms with their respective new viewstate values\n     *\n     */\n    processViewState(node: XMLQuery): boolean {\n        if (ResponseProcessor.isViewStateNode(node)) {\n            let state = node.cDATAAsString;\n            this.internalContext.assign(APPLIED_VST, node.id.value).value = new StateHolder($nsp(node.id.value), state);\n            return true;\n        }\n        return false;\n    }\n\n    processClientWindow(node: XMLQuery): boolean {\n        if (ResponseProcessor.isClientWindowNode(node)) {\n            let state = node.cDATAAsString;\n            this.internalContext.assign(APPLIED_CLIENT_WINDOW, node.id.value).value = new StateHolder($nsp(node.id.value), state);\n            return true;\n        }\n    }\n\n    /**\n     * generic global eval which runs the embedded css and scripts\n     */\n    globalEval() {\n        //  phase one, if we have head inserts, we build up those before going into the script eval phase\n        let insertHeadElems = new ExtDomquery(...this.internalContext.getIf(DEFERRED_HEAD_INSERTS).value);\n        insertHeadElems.runHeadInserts(true);\n\n        // phase 2 we run a script eval on all updated elements in the body\n        let updateElems = new ExtDomquery(...this.internalContext.getIf(UPDATE_ELEMS).value);\n        updateElems.runCss();\n        // phase 3, we do the same for the css\n        updateElems.runScripts();\n    }\n\n    /**\n     * Postprocessing view state fixing\n     * this appends basically the incoming view states to the forms.\n     * It is called from outside after all forms have been processed basically\n     * as last lifecycle step, before going into the next request.\n     */\n    fixViewStates() {\n        Stream.ofAssoc<StateHolder>(this.internalContext.getIf(APPLIED_VST).orElse({}).value)\n            .each((item: Array<any>) => {\n                let value: StateHolder = item[1];\n                let nameSpace = DQ.byId(value.nameSpace, true).orElse(document.body);\n                let affectedForms = nameSpace.byTagName(TAG_FORM);\n                let affectedForms2 = nameSpace.filter(item => item.tagName.orElse(EMPTY_STR).value.toLowerCase() == TAG_FORM);\n\n                this.appendViewStateToForms(new DomQuery(affectedForms, affectedForms2), value.value);\n            });\n    }\n\n    /**\n     * same as with view states before applies the incoming client windows as last step after the rest of the processing\n     * is done.\n     */\n    fixClientWindow() {\n        Stream.ofAssoc<StateHolder>(this.internalContext.getIf(APPLIED_CLIENT_WINDOW).orElse({}).value)\n            .each((item: Array<any>) => {\n                let value: StateHolder = item[1];\n                let nameSpace = DQ.byId(value.nameSpace, true).orElse(document.body);\n                let affectedForms = nameSpace.byTagName(TAG_FORM);\n                let affectedForms2 = nameSpace.filter(item => item.tagName.orElse(EMPTY_STR).value.toLowerCase() == TAG_FORM);\n\n                this.appendClientWindowToForms(new DomQuery(affectedForms, affectedForms2), value.value);\n            });\n    }\n\n    /**\n     * all processing done we can close the request and send the appropriate events\n     */\n    done() {\n        let eventData = EventData.createFromRequest(this.request.value, this.externalContext, SUCCESS);\n\n        //because some frameworks might decorate them over the context in the response\n        let eventHandler = this.externalContext.getIf(ON_EVENT).orElseLazy(() => this.internalContext.getIf(ON_EVENT).value).orElse(EMPTY_FUNC).value;\n        Implementation.sendEvent(eventData, eventHandler);\n    }\n\n    /**\n     * proper viewstate -> form assignment\n     *\n     * @param forms the forms to append the viewstate to\n     * @param viewState the final viewstate\n     */\n    private appendViewStateToForms(forms: DQ, viewState: string) {\n        this.assignState(forms, $nsp(SEL_VIEWSTATE_ELEM), viewState);\n    }\n\n\n    /**\n     * proper clientwindow -> form assignment\n     *\n     * @param forms the forms to append the viewstate to\n     * @param clientWindow the final viewstate\n     */\n    private appendClientWindowToForms(forms: DQ, clientWindow: string) {\n        this.assignState(forms, $nsp(SEL_CLIENT_WINDOW_ELEM), clientWindow);\n    }\n\n    /**\n     * generic append state which appends a certain state as hidden element to an existing set of forms\n     *\n     * @param forms the forms to append or change to\n     * @param selector the selector for the state\n     * @param state the state itself which needs to be assigned\n     *\n     * @private\n     */\n    private assignState(forms: DQ, selector: string, state: string) {\n        forms.each((form: DQ) => {\n            let stateHolders = form.querySelectorAll(selector)\n                .orElseLazy(() => ResponseProcessor.newViewStateElement(form));\n\n            stateHolders.attr(\"value\").value = state;\n        });\n    }\n\n    /**\n     * Helper to Create a new JSF ViewState Element\n     *\n     * @param parent, the parent node to attach the viewstate element to\n     * (usually a form node)\n     */\n    private static newViewStateElement(parent: DQ): DQ {\n        let newViewState = DQ.fromMarkup($nsp(HTML_VIEWSTATE));\n        newViewState.appendTo(parent);\n        return newViewState;\n    }\n\n    /**\n     * Stores certain aspects of the dom for later post processing\n     *\n     * @param updateForms the update forms which should receive standardized internal jsf data\n     * @param toBeEvaled the resulting elements which should be evaled\n     */\n    private storeForPostProcessing(updateForms: DQ, toBeEvaled: DQ) {\n        this.storeForUpdate(updateForms);\n        this.storeForEval(toBeEvaled);\n    }\n\n    /**\n     * helper to store a given form for the update post processing (viewstate)\n     *\n     * @param updateForms the dom query object pointing to the forms which need to be updated\n     */\n    private storeForUpdate(updateForms: DQ) {\n        this.internalContext.assign(UPDATE_FORMS).value.push(updateForms);\n    }\n\n    /**\n     * same for eval (js and css)\n     *\n     * @param toBeEvaled\n     */\n    private storeForEval(toBeEvaled: DQ) {\n        this.internalContext.assign(UPDATE_ELEMS).value.push(toBeEvaled);\n    }\n\n    // head eval is always sticky\n    private storeForHeadEval(toBeEvaled: DQ, sticky) {\n        this.internalContext.assign(DEFERRED_HEAD_INSERTS).value.push(toBeEvaled);\n    }\n\n    /**\n     * check whether a given XMLQuery node is an explicit viewstate node\n     *\n     * @param node the node to check\n     * @returns true of it ii\n     */\n    private static isViewStateNode(node: XMLQuery): boolean {\n        let separatorChar = (window?.faces ?? window?.jsf).separatorchar;\n        return \"undefined\" != typeof node?.id?.value && (node?.id?.value == $nsp(P_VIEWSTATE) ||\n            node?.id?.value?.indexOf([separatorChar, $nsp(P_VIEWSTATE)].join(EMPTY_STR)) != -1 ||\n            node?.id?.value?.indexOf([$nsp(P_VIEWSTATE), separatorChar].join(EMPTY_STR)) != -1);\n    }\n\n    /**\n     * incoming client window node also needs special processing\n     *\n     * @param node the node to check\n     * @returns true of it ii\n     */\n    private static isClientWindowNode(node: XMLQuery): boolean {\n        let separatorChar = (window?.faces ?? window?.jsf).separatorchar;\n        return \"undefined\" != typeof node?.id?.value && (node?.id?.value == $nsp(P_CLIENT_WINDOW) ||\n            node?.id?.value?.indexOf([separatorChar, $nsp(P_CLIENT_WINDOW)].join(EMPTY_STR)) != -1 ||\n            node?.id?.value?.indexOf([$nsp(P_CLIENT_WINDOW), separatorChar].join(EMPTY_STR)) != -1);\n    }\n\n    private triggerOnError(errorData: ErrorData) {\n        this.externalContext.getIf(ON_ERROR).orElse(this.internalContext.getIf(ON_ERROR).value).orElse(EMPTY_FUNC).value(errorData);\n    }\n\n\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {ArrayCollector, Config, DQ, Lang, LazyStream, Stream} from \"mona-dish\";\nimport {EMPTY_STR, IDENT_ALL, IDENT_FORM, P_VIEWSTATE} from \"../core/Const\";\nimport isString = Lang.isString;\nimport {ExtConfig} from \"../util/ExtDomQuery\";\n\n\n/**\n * A unified form data class\n * which builds upon our configuration.\n *\n * We cannot use standard html5 forms everywhere\n * due to api constraints on the HTML Form object in IE11\n * and due to the url encoding constraint given by the faces.js spec\n *\n * probably only one needed and one overlay!\n * the entire file input storing probably is redundant now\n * that dom query has been fixed //TODO check this\n */\nexport class XhrFormData extends Config {\n    /**\n     * Checks if the given datasource is a multipart request source\n     * multipart is only needed if one of the executes is a file input\n     * since file inputs are stateless, they fall out of the view state\n     * and need special handling. With file submits we have to send a formData object\n     * instead of an encoded string files cannot be sent that way\n     */\n    isMultipartRequest: boolean = false;\n\n    /**\n     * data collector from a given form\n     *\n     * @param dataSource either a form as DomQuery object or an encoded url string\n     * @param viewState the form view state or an external viewstate coming in as string\n     * @param executes the executes id list for the elements to being processed\n     * @param partialIds partial ids to collect, to reduce the data sent down\n     */\n    constructor(private dataSource: DQ | string, viewState?: string, executes?: string[], private partialIds?: string[]) {\n        super({});\n        //a call to getViewState before must pass the encoded line\n        //a call from getViewState passes the form element as datasource,\n        //so we have two call points\n        if (isString(dataSource)) {\n            this.assignEncodedString(<string>this.dataSource);\n        } else {\n            this.applyFormDataToConfig();\n        }\n        if('undefined' != typeof viewState) {\n            this.assignEncodedString(viewState)\n        }\n        if(executes) {\n            this.postInit(...executes);\n        }\n    }\n\n    /**\n     * generic post init code, for now, this peforms some post assign data post processing\n     * @param executes\n     */\n    postInit(...executes: Array<string>) {\n        let fetchInput = (id: string): DQ => {\n            if (id == IDENT_ALL) {\n                return DQ.querySelectorAllDeep(\"input[type='file']\");\n            } else if (id == IDENT_FORM) {\n                return (<DQ>this.dataSource).querySelectorAllDeep(\"input[type='file']\");\n            } else {\n                let element = DQ.byId(id, true);\n                return this.getFileInputs(element);\n            }\n        };\n\n        let inputExists = (item: DQ) => {\n            return item.isPresent();\n        };\n\n\n        this.isMultipartRequest = LazyStream.of(...executes)\n            .map(fetchInput)\n            .filter(inputExists)\n            .first().isPresent();\n    }\n\n    /**\n     * special case view state handling\n     *\n     * @param form the form holding the view state value\n     */\n    private applyViewState(form: DQ) {\n        let viewState = form.byId(P_VIEWSTATE, true).inputValue;\n        this.appendIf(viewState.isPresent(), P_VIEWSTATE).value = viewState.value;\n    }\n\n    /**\n     * assigns an url encoded string to this xhrFormData object\n     * as key value entry\n     * @param encoded\n     */\n    assignEncodedString(encoded: string) {\n        // this code filters out empty strings as key value pairs\n        let keyValueEntries = decodeURIComponent(encoded).split(/&/gi)\n                .filter(item => !!(item || '')\n                .replace(/\\s+/g,''));\n        this.assignString(keyValueEntries);\n    }\n\n    /**\n     * assign a set of key value pairs passed as array ['key=val1', 'key2=val2']\n     * @param keyValueEntries\n     */\n    assignString(keyValueEntries: string[]) {\n        let toMerge = new ExtConfig({});\n\n        function splitToKeyVal(line: string) {\n            return line.split(/=(.*)/gi);\n        }\n\n        function fixKeyWithoutVal(keyVal: string[]) {\n            return keyVal.length < 3 ? [keyVal?.[0] ?? [], keyVal?.[1] ?? []] : keyVal;\n        }\n\n        Stream.of(...keyValueEntries)\n            //split only the first =\n            .map(line => splitToKeyVal(line))\n            //special case of having keys without values\n            .map(keyVal => fixKeyWithoutVal(keyVal))\n            .each(keyVal => {\n                toMerge.append(keyVal[0] as string).value = keyVal?.splice(1)?.join(\"\") ?? \"\";\n            });\n        //merge with overwrite but no append! (aka no double entries are allowed)\n        this.shallowMerge(toMerge);\n    }\n\n    /**\n     * @returns a Form data representation, this is needed for file submits\n     */\n    toFormData(): FormData {\n        let ret: any = new FormData();\n        this.appendInputs(ret);\n        return ret;\n    }\n\n    resolveSubmitIdentifier(elem: HTMLInputElement) {\n        let identifier = elem.name;\n        identifier = ((elem?.name ?? \"\").replace(/s+/gi, \"\") == \"\") ? elem.id : identifier;\n        return identifier;\n    }\n\n    /**\n     * returns an encoded string representation of our xhr form data\n     *\n     * @param defaultStr optional default value if nothing is there to encode\n     */\n    toString(defaultStr = EMPTY_STR): string {\n        if (this.isAbsent()) {\n            return defaultStr;\n        }\n        let entries = LazyStream.of(...Object.keys(this.value))\n            .filter(key => this.value.hasOwnProperty(key))\n            .flatMap(key => Stream.of(...this.value[key]).map(val => [key, val]).collect(new ArrayCollector()))\n            .map(keyVal => {\n                return `${encodeURIComponent(keyVal[0])}=${encodeURIComponent(keyVal[1])}`;\n            })\n            .collect(new ArrayCollector());\n\n        return entries.join(\"&\")\n    }\n\n    /**\n     * helper to fetch all file inputs from as given root element\n     * @param rootElement\n     * @private\n     */\n    private getFileInputs(rootElement: DQ): DQ {\n        const rootFileInputs = rootElement\n            .filter(elem => elem.matchesSelector(\"input[type='file']\"))\n        const childFileInputs = rootElement\n            .querySelectorAll(\"input[type='file']\");\n\n        return rootFileInputs.concat(childFileInputs);\n    }\n\n    /**\n     * encode the given fields and apply the view state\n     * @private\n     */\n    private applyFormDataToConfig() {\n        //encode and append the issuing item if not a partial ids array of ids is passed\n        /*\n         * Spec. 13.3.1\n         * Collect and encode input elements.\n         * Additionally the hidden element jakarta.faces.ViewState\n         * Enhancement partial page submit\n         *\n         */\n        this.encodeSubmittableFields(this, <DQ>this.dataSource, this.partialIds);\n\n        if (this.getIf(P_VIEWSTATE).isPresent()) {\n            return;\n        }\n\n        this.applyViewState(<DQ>this.dataSource);\n    }\n\n    /**\n     * determines fields to submit\n     * @param {Object} targetBuf - the target form buffer receiving the data\n     * @param {Node} parentItem - form element item is nested in\n     * @param {Array} partialIds - ids fo PPS\n     */\n    private encodeSubmittableFields(targetBuf: Config,\n                                    parentItem: DQ, partialIds ?: string[]) {\n        let toEncode = null;\n        if (this.partialIds && this.partialIds.length) {\n            // in case of our myfaces reduced ppr we\n            // only submit the partials\n            this._value = {};\n            toEncode = new DQ(...this.partialIds);\n\n        } else {\n            if (parentItem.isAbsent()) throw 'NO_PAR_ITEM';\n            toEncode = parentItem;\n        }\n\n        //lets encode the form elements\n        this.shallowMerge(toEncode.deepElements.encodeFormElement());\n    }\n\n    private appendInputs(ret: any) {\n        Stream.of(...Object.keys(this.value))\n            .each(key => {\n                Stream.of(...this.value[key]).each(item => ret.append(key, item));\n            });\n    }\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {AsyncRunnable} from \"../util/AsyncRunnable\";\nimport {Config, DQ, Stream} from \"mona-dish\";\nimport {Implementation} from \"../AjaxImpl\";\n\nimport {XhrFormData} from \"./XhrFormData\";\nimport {ErrorData} from \"./ErrorData\";\nimport {EventData} from \"./EventData\";\nimport {ExtLang} from \"../util/Lang\";\nimport {\n    BEGIN,\n    COMPLETE,\n    CONTENT_TYPE,\n    CTX_PARAM_MF_INTERNAL,\n    CTX_PARAM_PASS_THR,\n    ERROR,\n    HEAD_FACES_REQ,\n    MALFORMEDXML,\n    NO_TIMEOUT,\n    ON_ERROR,\n    ON_EVENT, P_EXECUTE,\n    REQ_ACCEPT,\n    REQ_TYPE_GET,\n    REQ_TYPE_POST,\n    STATE_EVT_TIMEOUT,\n    STD_ACCEPT,\n    URL_ENCODED,\n    VAL_AJAX\n} from \"../core/Const\";\nimport {resolveFinalUrl, resolveHandlerFunc} from \"./RequestDataResolver\";\nimport failSaveExecute = ExtLang.failSaveExecute;\n\n/**\n * Faces XHR Request Wrapper\n * as Asyncrunnable for our Asynchronous queue\n *\n * The idea is that we basically just enqueue\n * a single ajax request into our queue\n * and let the queue do the processing.\n *\n */\n\nexport class XhrRequest implements AsyncRunnable<XMLHttpRequest> {\n\n    private responseContext: Config;\n\n    private stopProgress = false;\n\n    /**\n     * helper support so that we do not have to drag in Promise shims\n     */\n    private catchFuncs: Array<Function> = [];\n    private thenFunc: Array<Function> = [];\n\n    /**\n     * Reqired Parameters\n     *\n     * @param source the issuing element\n     * @param sourceForm the form which is related to the issuing element\n     * @param requestContext the request context with all pass through values\n     *\n     * Optional Parameters\n     *\n     * @param internalContext internal context with internal info which is passed through, not used by the user\n     * @param partialIdsArray an optional restricting partial ids array for encoding\n     * @param timeout optional xhr timeout\n     * @param ajaxType optional request type, default \"POST\"\n     * @param contentType optional content type, default \"application/x-www-form-urlencoded\"\n     * @param xhrObject optional xhr object which must fullfill the XMLHTTPRequest api, default XMLHttpRequest\n     */\n    constructor(\n        private source: DQ,\n        private sourceForm: DQ,\n        private requestContext: Config,\n        private internalContext: Config,\n        private partialIdsArray = [],\n        private timeout = NO_TIMEOUT,\n        private ajaxType = REQ_TYPE_POST,\n        private contentType = URL_ENCODED,\n        private xhrObject = new XMLHttpRequest()\n    ) {\n        /*\n        * we omit promises here\n        * some browsers do not support it and we do not need shim code\n        */\n        this.registerXhrCallbacks((data: any) => {\n            this.resolve(data)\n        }, (data: any) => {\n            this.reject(data)\n        });\n    }\n\n    start(): AsyncRunnable<XMLHttpRequest> {\n\n        let ignoreErr = failSaveExecute;\n        let xhrObject = this.xhrObject;\n\n        let executesArr = () => {\n            return this.requestContext.getIf(CTX_PARAM_PASS_THR, P_EXECUTE).get(\"none\").value.split(/\\s+/gi);\n        };\n        try {\n\n            let formElement = this.sourceForm.getAsElem(0).value;\n            let viewState = (window?.faces ?? window?.jsf).getViewState(formElement);\n            //encoded we need to decode\n            //We generated a base representation of the current form\n            //in case someone has overloaded the viewstate with addtional decorators we merge\n            //that in, there is no way around it, the spec allows it and getViewState\n            //must be called, so whatever getViewState delivers has higher priority then\n            //whatever the formData object delivers\n            //the partialIdsArray arr is almost deprecated legacy code where we allowed to send a separate list of partial\n            //ids for reduced load and server processing, this will be removed soon, we can handle the same via execute\n            //anyway TODO remove the partial ids array\n            let formData: XhrFormData = new XhrFormData(this.sourceForm, viewState, executesArr(), this.partialIdsArray);\n\n            this.contentType = formData.isMultipartRequest ? \"undefined\" : this.contentType;\n\n            //next step the pass through parameters are merged in for post params\n            let requestContext = this.requestContext;\n            let passThroughParams = requestContext.getIf(CTX_PARAM_PASS_THR);\n\n            // this is an extension where we allow pass through parameters to be sent down additionally\n            // this can be used and is used in the impl to enrich the post request parameters with additional\n            // information\n            formData.shallowMerge(passThroughParams, true, true);\n\n            this.responseContext = passThroughParams.deepCopy;\n\n            //we have to shift the internal passthroughs around to build up our response context\n            let responseContext = this.responseContext;\n\n            responseContext.assign(CTX_PARAM_MF_INTERNAL).value = this.internalContext.value;\n\n            //per spec the onevent and onerrors must be passed through to the response\n            responseContext.assign(ON_EVENT).value = requestContext.getIf(ON_EVENT).value;\n            responseContext.assign(ON_ERROR).value = requestContext.getIf(ON_ERROR).value;\n\n            xhrObject.open(this.ajaxType, resolveFinalUrl(this.sourceForm, formData, this.ajaxType), true);\n\n            //adding timeout\n            this.timeout ? xhrObject.timeout = this.timeout : null;\n\n            //a bug in the xhr stub library prevents the setRequestHeader to be properly executed on fake xhr objects\n            //normal browsers should resolve this\n            //tests can quietly fail on this one\n            if(this.contentType != \"undefined\") {\n                ignoreErr(() => xhrObject.setRequestHeader(CONTENT_TYPE, `${this.contentType}; charset=utf-8`));\n            }\n\n            ignoreErr(() => xhrObject.setRequestHeader(HEAD_FACES_REQ, VAL_AJAX));\n\n            //probably not needed anymore, will test this\n            //some webkit based mobile browsers do not follow the w3c spec of\n            // setting, they accept headers automatically\n            ignoreErr(() => xhrObject.setRequestHeader(REQ_ACCEPT, STD_ACCEPT));\n\n            this.sendEvent(BEGIN);\n\n            this.sendRequest(formData);\n\n        } catch (e) {\n            //_onError//_onError\n            this.handleError(e);\n        }\n        return this;\n    }\n\n    cancel() {\n        try {\n            this.xhrObject.abort();\n        } catch (e) {\n            this.handleError(e);\n        }\n    }\n\n    resolve(data: any) {\n        Stream.of(...this.thenFunc).reduce((inputVal: any, thenFunc: any) => {\n            return thenFunc(inputVal);\n        }, data);\n    }\n\n    reject(data: any) {\n        Stream.of(...this.catchFuncs).reduce((inputVal: any, catchFunc: any) => {\n            return catchFunc(inputVal);\n        }, data);\n    }\n\n    catch(func: (data: any) => any): AsyncRunnable<XMLHttpRequest> {\n        this.catchFuncs.push(func);\n        return this;\n    }\n\n    finally(func: () => void): AsyncRunnable<XMLHttpRequest> {\n        //no ie11 support we probably are going to revert to shims for that one\n        this.catchFuncs.push(func);\n        this.thenFunc.push(func);\n        return this;\n    }\n\n    then(func: (data: any) => any): AsyncRunnable<XMLHttpRequest> {\n        //this.$promise.then(func);\n        this.thenFunc.push(func);\n        return this;\n    }\n\n    /**\n     * attaches the internal event and processing\n     * callback within the promise to our xhr object\n     *\n     * @param resolve\n     * @param reject\n     */\n    private registerXhrCallbacks(resolve: Consumer<any>, reject: Consumer<any>) {\n        let xhrObject = this.xhrObject;\n\n        xhrObject.onabort = () => {\n            this.onAbort(reject);\n        };\n        xhrObject.ontimeout = () => {\n            this.onTimeout(reject);\n        };\n        xhrObject.onload = () => {\n            this.onSuccess(resolve)\n        };\n        xhrObject.onloadend = () => {\n            this.onDone(this.xhrObject, resolve);\n        };\n        xhrObject.onerror = (errorData: any) => {\n            // some browsers trigger an error when cancelling a request internally\n            // in this case we simply ignore the request and clear up the queue, because\n            // it is not safe anymore to proceed with the current queue\n\n            // This bypasses a Safari issue where it keeps requests hanging after page unload\n            // and then triggers a cancel error on then instead of just stopping\n            // and clearing the code\n            if(this.isCancelledResponse(this.xhrObject)) {\n                reject();\n                this.stopProgress = true;\n                return;\n            }\n            this.onError(errorData, reject);\n        };\n    }\n\n    private isCancelledResponse(currentTarget: XMLHttpRequest): boolean {\n        return currentTarget?.status === 0 && //cancelled by browser\n            currentTarget?.readyState === 4 &&\n            currentTarget?.responseText === '' &&\n            currentTarget?.responseXML === null;\n    }\n\n    /*\n         * xhr processing callbacks\n         *\n         * Those methods are the callbacks called by\n         * the xhr object depending on its own state\n         */\n\n    private onAbort(reject: Consumer<any>) {\n        reject();\n    }\n\n    private onTimeout(reject: Consumer<any>) {\n        this.sendEvent(STATE_EVT_TIMEOUT);\n        reject();\n    }\n\n    private onSuccess(resolve: Consumer<any>) {\n\n        this.sendEvent(COMPLETE);\n\n        //malforms always result in empty response xml\n        if (!this?.xhrObject?.responseXML) {\n            this.handleMalFormedXML(resolve);\n            return;\n        }\n\n        (window?.faces ?? window.jsf).ajax.response(this.xhrObject, this.responseContext.value ?? {});\n    }\n\n    private handleMalFormedXML(resolve: Function) {\n        this.stopProgress = true;\n        let errorData = {\n            type: ERROR,\n            status: MALFORMEDXML,\n            responseCode: 200,\n            responseText: this.xhrObject?.responseText,\n            source: {\n                id: this.source.id.value\n            }\n        };\n        try {\n            this.handleError(errorData, true);\n        } finally {\n            // we issue a resolve in this case to allow the system to recover\n            // reject would clean up the queue\n            resolve(errorData);\n        }\n        //non blocking non clearing\n    }\n\n    private onDone(data: any, resolve: Consumer<any>) {\n        // if stop progress a special handling including resolve is already performed\n        if (this.stopProgress) {\n            return;\n        }\n        resolve(data);\n    }\n\n    private onError(errorData: any,  reject: Consumer<any>) {\n        this.handleError(errorData);\n        reject();\n    }\n\n    private sendRequest(formData: XhrFormData) {\n        let isPost = this.ajaxType != REQ_TYPE_GET;\n        if (formData.isMultipartRequest) {\n            //in case of a multipart request we send in a formData object as body\n            this.xhrObject.send((isPost) ? formData.toFormData() : null);\n        } else {\n            //in case of a normal request we send it normally\n            this.xhrObject.send((isPost) ? formData.toString() : null);\n        }\n    }\n\n    /*\n     * other helpers\n     */\n    private sendEvent(evtType: string) {\n        let eventData = EventData.createFromRequest(this.xhrObject, this.requestContext, evtType);\n        try {\n            //user code error, we might cover\n            //this in onError but also we cannot swallow it\n            //we need to resolve the local handlers lazily,\n            //because some frameworks might decorate them over the context in the response\n            let eventHandler = resolveHandlerFunc(this.requestContext, this.responseContext, ON_EVENT);\n\n            Implementation.sendEvent(eventData, eventHandler);\n        } catch (e) {\n            this.handleError(e);\n            throw e;\n        }\n    }\n\n    private handleError(exception, responseFormatError: boolean = false) {\n        let errorData = (responseFormatError) ? ErrorData.fromHttpConnection(exception.source, exception.type, exception.status, exception.responseText, exception.responseCode, exception.status) : ErrorData.fromClient(exception);\n\n        let eventHandler = resolveHandlerFunc(this.requestContext, this.responseContext, ON_ERROR);\n        Implementation.sendError(errorData, eventHandler);\n    }\n\n}","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {DQ, Stream} from \"mona-dish\";\n\n/**\n * legacy code to enable various aspects\n * of myfaces, used to be rendered inline\n * for jsf 2.0 we can externalize it into its own custom resource\n *\n * note this is a straight 1:1 port from the existing codebase\n * (not too much work has been spent here, the important thing is, that\n * the namespace and functions need to be kept intact for legacy code)\n *\n * we might move the code over in the future, but for now a straight 1:1 port suffices\n */\nexport module oam {\n    /**\n     * sets a hidden input field\n     * @param formName the formName\n     * @param name the hidden field\n     * @param value the value to be rendered\n     */\n    export const setHiddenInput = function (formName: string, name: string, value: string): void {\n        DQ.byId(document.forms[formName])\n            .each(form => {\n                const input = form.querySelectorAll(`input[type='hidden'][name='${name}']`);\n                if (input.isPresent()) {\n                    input.inputValue.value = value;\n                } else {\n                    const newInput = DQ.fromMarkup(`<input type='hidden' id='${name}' name='${name}'>`);\n                    newInput.inputValue.value = value;\n                    newInput.appendTo(form);\n                }\n            });\n    };\n\n    /**\n     * clears a hidden input field\n     *\n     * @param formName formName for the input\n     * @param name the name of the input field\n     */\n    export const clearHiddenInput = function (formName: string, name: string): void {\n        let element = document.forms?.[formName]?.elements?.[name];\n        if(!element) {\n            return;\n        }\n        DQ.byId(element).delete();\n    };\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * does special form submit remapping\n     * re-maps the issuing command link into something,\n     * a decode of the command link on the server can understand\n     *\n     * @param formName\n     * @param linkId\n     * @param target\n     * @param params\n     */\n    export const submitForm = function (formName: string, linkId: string, target: string, params: { [key: string]: any }): boolean {\n        let clearFn = 'clearFormHiddenParams_' + formName.replace(/-/g, '\\$:').replace(/:/g, '_');\n        window?.[clearFn]?.(formName);\n\n        //autoscroll code\n        if (window?.myfaces?.core?.config?.autoScroll && (window as any)?.getScrolling) {\n            myfaces.oam.setHiddenInput(formName, 'autoScroll', (window as any)?.getScrolling());\n        }\n        Stream.ofAssoc(params).each((param: [string, any]) => {\n            myfaces.oam.setHiddenInput(formName, param[0], param[1]);\n        });\n\n        //we call the namespaced function, to allow decoration, via a direct call we would\n        myfaces.oam.setHiddenInput(formName, `${formName}:_idcl`, linkId);\n\n        DQ.byId(document.forms[formName]).each(form => {\n            const ATTR_TARGET = \"target\";\n            const formElement = form.getAsElem(0).value as HTMLFormElement;\n            const oldTarget = form.attr(ATTR_TARGET).value;\n            form.attr(ATTR_TARGET).value = target;\n\n            const result = formElement?.onsubmit?.(null);\n\n            try {\n                if ((!!result) || 'undefined' == typeof result) {\n                    formElement.submit();\n                }\n            } catch (e) {\n                window?.console.error(e);\n            } finally {\n                form.attr(ATTR_TARGET).value = oldTarget;\n                Stream.ofAssoc(params).each((param: [string, any]) => {\n                    myfaces.oam.clearHiddenInput(formName, param[0]);\n                });\n                myfaces.oam.clearHiddenInput(formName, `${formName}:_idcl`);\n            }\n\n        });\n        return false;\n    };\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","/*! Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\n/**\n * faces.js init layer which provides as per spec the proper\n * window namespace if it does not exist already\n *\n * The idea is that we use a small shim on top of\n * the implementation to provide the window namespace.\n * The implementation itself is in a protected namespace\n * which will be bound by the build system\n *\n * The documentation nevertheless targets the _api file, which\n * hosts the full api\n */\nif(!window.faces) {\n    //we lazily load the code to prevent ram bloat\n    const faces = require(\"./_api\").faces;\n    window['faces'] = window?.faces ?? faces;\n}\nif(!window?.myfaces?.ab) {\n    const myfaces = require(\"./_api\").myfaces;\n\n    //namespace might be extended is not exclusively reserved so we merge\n    (window as any)[\"myfaces\"] = window?.myfaces ?? {};\n    Object.keys(myfaces).forEach(key => window.myfaces[key] = window.myfaces?.[key] ?? myfaces[key]);\n}\nexport var faces = window.faces;\nexport var myfaces = window.myfaces;\n"],"names":["trim","Lang","objToArray","isString","equalsIgnoreCase","Submittables","ElementAttribute","ValueEmbedder","constructor","element","name","defaultVal","super","value","val","this","get","orElse","values","length","getAttribute","cnt","setAttribute","getClass","static","valueKey","Style","style","DEFAULT_WHITELIST","DomQuery","rootNode","pos","_limits","Optional","fromNullable","isAbsent","foundElement","querySelectorAll","push","getAsElem","allElems","global","_global$","id","tagName","getIf","nodeName","isTag","toLowerCase","type","inputValue","isPresent","absent","checked","Stream","of","allMatch","el","newChecked","eachElem","elements","deepElements","querySelectorAllDeep","queryStr","found","queryRes","shadowRoots","shadowRoot","shadowRes","disabled","attr","removeAttribute","item","childNodes","childNodeArr","concat","stream","asArray","lazyStream","LazyStream","filter","map","byId","collect","ArrayCollector","offsetWidth","elem","reduce","accumulate","incoming","offsetHeight","offsetLeft","offsetTop","asNodeArray","selector","document","indexOf","_querySelectorAllDeep","_querySelectorAll","deep","byIdDeep","byTagName","code","nonce","globalEval","globalEvalSticky","markup","doc","implementation","createHTMLDocument","lowerMarkup","documentElement","innerHTML","startsWithTag","str","tag1","join","tag2","dummyPlaceHolder","createElement","html","detach","index","defaults","filesFromElem","files","presentRunnable","call","ifPresentLazy","delete","node","parentNode","removeChild","nodes","res","foundNodes","selectors","split","cnt2","levelSelector","includeRoot","subItems","reduction","defaultValue","cssProperty","hasClass","clazz","hasIt","classList","contains","addClass","add","removeClass","remove","isMultipartCandidate","FILE_INPUT","matchesSelector","first","inval","dispatchEvent","evt","inVal","retArr","innerHtml","_mozMatchesSelector","toMatch","prot","matches","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","s","ownerDocument","i","filterSelector","matched","match","nodeSelector","selectorStage","func","len","firstElem","lastElem","each","last","lastNode","reArr","head","getElementsByTagName","script","newScriptElement","appendChild","appendTo","orElseLazy","loadScriptEval","src","defer","charSet","srcNode","createSourceNode","setTimeout","loadScriptEvalSticky","insertAfter","toInsertParams","existingItem","existingElement","nextSibling","insertElem","insertBefore","elseValue","parents","retSet","Set","lowerTagName","resolveItem","has","host","copyAttrs","sourceItem","sourceNode","attrs","attributes","resolveAttributeHolder","attrName","ret","outerHTML","runEmbeddedScripts","runEmbeddedCss","focusElementId","activeElement","caretPosition","getCaretPosition","fromMarkup","toReplace","firstInsert","replaced","replaceChild","insertAdditionalItems","slice","runScripts","runCss","focusElement","setCaretPosition","sticky","whilteListed","evalCollectedScripts","scriptsToProcess","joinedScripts","evalText","finalScripts","equi","execScrpt","itemType","text","innerText","go","substring","flatMap","sort","node1","node2","compareDocumentPosition","e","console","error","message","description","applyStyle","newSS","styleSheet","sheet","cssText","createTextNode","Array","prototype","forEach","child","data","execCss","click","fireEvent","addEventListener","listener","options","removeEventListener","eventName","nodeType","Error","eventClass","event","createEvent","initEvent","synthetic","createEventObject","textContent","joinstr","text1","text2","encodeFormElement","toMerge","Config","target","shallowCopy","elemType","selectElem","selectedIndex","uLen","u","selected","elementOption","append","SELECT","BUTTON","RESET","SUBMIT","IMAGE","CHECKBOX","RADIO","cDATAAsString","reduced","subNodes","from","to","Math","min","limits","end","hasNext","isLimitsReached","isEndOfArray","next","lookAhead","ITERATION_STATUS","EO_STRM","current","BEF_STRM","reset","attachShadow","params","mode","shadowElement","waitUntilDom","condition","childList","subtree","timeout","interval","root","Promise","success","observer","MUT_ERROR","findElement","MutationObserver","mutTimeout","disconnect","callback","mutationList","mut","clearTimeout","observableOpts","observe","setInterval","clearInterval","shadowElements","mapped","hasShadow","ctrl","caretPos","selection","focus","createRange","moveStart","setSelectiongRange","Symbol","iterator","done","toAttach","filterDoubles","DomQueryCollector","idx","notFound","prependTo","prepend","finalValue","DQ","DQ$","globalThis","window","g","ws","replace","test","charAt","it","arguments","String","saveResolve","resolverProducer","result","saveResolveLazy","strToArray","splitter","obj","offset","pack","source","destination","finalDest","assertType","probe","theType","isFunc","Function","objAssign","theArgs","TypeError","Object","assign","nextSource","keys","nextKey","hasOwnProperty","Monad","_value","fn","key","currentPos","currKey","keyVal","arrPos","arrayIndex","getIfPresent","toJson","JSON","stringify","start","parseInt","resolve","resolver","rootElem","newVal","alternative","ConfigEntry","shallowCopy$","ofAssoc","AssocArrayCollector","deepCopy","deepCopy$","shallowMerge","other","overwrite","withAppend","isArray","accessPath","lastKey","pathExists","buildPath","finalKeyArrPos","apply","appendIf","assignIf","setVal","parentVal","parentPos","alloc","arr","length1","length2","tempVal","total","ArrayStreamDataSource","dataPos","max","filterFunc","parent","_current","_filterIdx","_unfilteredPos","inputDataSource","steps","lookupVal","loop","mapFunc","lookAheadVal","walkedDataSources","_currPos","resolveActiveHasNext","resolveNextHasNext","activeDataSource","readjustSkip","dataSource","skippedElems","datasource","howManyElems","dsLoop","currDatasource","toDatasource","ds","FormData","formData","item1","item2","toAppend","onElem","strmR","startVal","val1","anyMatch","noneMatch","comparator","newArr","collector","isOverLimits","nextFilter","t","MappedStreamDataSource","stop","FilteredStreamDatasource","FlatMapStreamDataSource","value1","value2","el1","el2","XMLQuery","docType","xml","DOMParser","parser","ActiveXObject","async","parseFromString","contentType","loadXML","createIe11DomQueryShim","isXMLParserError","toString","serialized","XMLSerializer","serializeToString","parserErrorText","txt","parseType","XQ","SequenceDataSource","QueryFormStringCollector","FormDataCollector","QueryFormDataCollector","faces","ajax","util","specversion","implversion","separatorchar","sep","Implementation","getSeparatorChar","contextpath","getProjectStage","getViewState","formElement","getClientWindow","request","response","context","addOnError","errorFunc","addOnEvent","eventFunc","chain","funcs","init","socketClientId","uri","channel","onopen","onmessage","onclose","behaviorScripts","autoconnect","PushImpl","open","close","myfaces","ab","execute","render","$nsp","P_BEHAVIOR_EVENT","CTX_PARAM_EXECUTE","CTX_PARAM_RENDER","jsf","oam","ProjectStages","BlockFilter","getMessage","ExtLang","getGlobalConfig","assert","Assertions","projectStage","separator","eventQueue","errorQueue","resolveProjectStateFromURL","foundStage","ExtDomquery","searchJsfJsFor","sendError","errorData","localHandler","errorCallback","alert","displayError","remapDefaultConstants","targetConfig","targetKey","userValues","issuingForm","issuingElementId","iterValues","processed","IDENT_NONE","IDENT_ALL","IDENT_FORM","IDENT_THIS","resolveGlobalConfig","MYFACES","config","requestQueue","getContextPath","sourceCode","resolveAndExecute","opResult","opts","resolvedEvent","elementId","requestCtx","internalCtx","windowId","isResetValues","resolveDefaults","assertRequestIntegrity","form","resolveForm","formId","delay","resolveDelay","resolveTimeout","mappedOpts","requestOptions","targetContext","sourceElementId","P_WINDOW_ID","CTX_PARAM_PASS_THR","P_EVT","SOURCE","ON_EVENT","onevent","ON_ERROR","onerror","P_PARTIAL_SOURCE","P_AJAX","P_RESET_VALUES","CTX_PARAM_SRC_FRM_ID","CTX_PARAM_SRC_CTL_ID","CTX_PARAM_TR_TYPE","REQ_TYPE_POST","clientWindow","P_CLIENT_WINDOW","assignClientWindowId","P_EXECUTE","P_RENDER","assignRender","queueHandler","addRequestToQueue","Response","processResponse","errorListener","eventListener","sendEvent","stdErrorHandler","exception","clearRequestQueue","ErrorData","fromClient","cleanup","ALTERED","INIT","formWindowId","body","TAG_FORM","XhrFormData","reqCtx","respPassThr","AsynchronousQueue","enqueue","XhrRequest","URL_PROTOCOL","location","protocol","sockets","components","clientIdsByTokens","resolveFunction","WebSocket","channelToken","substr","Socket","url","base","hostname","port","getBaseURL","getSocket","reconnectAttempts","socket","readyState","bindCallbacks","clientIds","onmmessage","parse","getElementById","functions","j","splice","reason","REASON_EXPIRED","MAX_RECONNECT_ATTEMPTS","RECONNECT_INTERVAL","PARTIAL_ID","P_VIEWSTATE","P_VIEWROOT","P_VIEWHEAD","P_VIEWBODY","P_RESOURCE","EMPTY_FUNC","freeze","EMPTY_STR","EMPTY_MAP","HTML_VIEWSTATE","WINDOW_ID","ERROR","EVENT","BEGIN","COMPLETE","SUCCESS","STATUS","ERROR_NAME","ERROR_MESSAGE","RESPONSE_TEXT","RESPONSE_XML","HTTPERROR","EMPTY_RESPONSE","MALFORMEDXML","SERVER_ERROR","CLIENT_ERROR","TIMEOUT_EVENT","CTX_PARAM_MF_INTERNAL","CTX_PARAM_DELAY","CTX_PARAM_TIMEOUT","CTX_PARAM_RST","STAGE_DEVELOPMENT","CONTENT_TYPE","HEAD_FACES_REQ","REQ_ACCEPT","VAL_AJAX","ENCODED_URL","REQ_TYPE_GET","STATE_EVT_BEGIN","STATE_EVT_TIMEOUT","STATE_EVT_COMPLETE","URL_ENCODED","MULTIPART","NO_TIMEOUT","STD_ACCEPT","TAG_HEAD","TAG_BODY","TAG_BEFORE","TAG_AFTER","TAG_ATTR","SEL_VIEWSTATE_ELEM","SEL_CLIENT_WINDOW_ELEM","SEL_RESPONSE_XML","PHASE_PROCESS_RESPONSE","ERR_NO_PARTIAL_RESPONSE","ATTR_URL","ATTR_NAME","ATTR_VALUE","ATTR_ID","RESP_PARTIAL","CMD_CHANGES","CMD_UPDATE","CMD_DELETE","CMD_INSERT","CMD_EVAL","CMD_ERROR","CMD_ATTRIBUTES","CMD_EXTENSION","CMD_REDIRECT","UPDATE_FORMS","UPDATE_ELEMS","DEFERRED_HEAD_INSERTS","SEL_SCRIPTS_STYLES","MF_NONE","APPLIED_VST","APPLIED_CLIENT_WINDOW","UNKNOWN","inputNamespace","viewStatePos","nameSpace","hasNameSpace","MSG_TEST","MSG_DEV_MODE","MSG_AFFECTED_CLASS","MSG_AFFECTED_METHOD","MSG_ERROR_NAME","MSG_ERROR_MESSAGE","MSG_SERVER_ERROR_NAME","MSG_ERROR_DESC","MSG_ERROR_NO","MSG_ERROR_LINENO","ERR_FORM","ERR_VIEWSTATE","ERR_TRANSPORT","ERR_EVT_PASS","ERR_CONSTRUCT","ERR_MALFORMEDXML","ERR_SOURCE_FUNC","ERR_EV_OR_UNKNOWN","ERR_SOURCE_NOSTR","ERR_SOURCE_DEF_NULL","ERR_MUST_STRING","ERR_REF_OR_ID","ERR_PARAM_GENERIC","ERR_PARAM_STR","ERR_PARAM_STR_RE","ERR_PARAM_MIXMAPS","ERR_MUST_BE_PROVIDED","ERR_MUST_BE_PROVIDED1","ERR_REPLACE_EL","ERR_EMPTY_RESPONSE","ERR_ITEM_ID_NOTFOUND","ERR_PPR_IDREQ","ERR_PPR_INSERTBEFID","ERR_PPR_INSERTBEFID_1","ERR_PPR_INSERTBEFID_2","ERR_PPR_DELID","ERR_PPR_UNKNOWNCID","ERR_NO_VIEWROOTATTR","ERR_NO_HEADATTR","ERR_RED_URL","ERR_REQ_FAILED_UNKNOWN","ERR_REQU_FAILED","makeException","msg","caller","title","raiseError","assertFunction","assertUrlExists","assertValidXMLResponse","responseXML","finalTitle","finalName","finalMessage","runnableQueue","isEmpty","delayTimeout","appendElement","dequeue","shift","currentlyRunning","cancel","callForNextElementToProcess","runEntry","catch","then","IS_FACES_SOURCE","search","ATTR_SRC","fetchWindowIdFromURL","href","results","RegExp","exec","ExtConfig","curScript","currentScript","extractNonce","nonceScript","rexp","decodeURIComponent","runHeadInserts","suppressDoubleIncludes","processedScripts","ExtDQ","acessPathMapped","remap","installedLocale","defaultMessage","templateParams","Messages","param","callerCls","callFunc","getLanguage","language","navigator","languages","failSaveResolve","failSaveExecute","keyValToStr","delimiter","configName","getForm","queryElem","eventTarget","getEventTarget","foundForm","assertFormExists","getLocalOrGlobalConfig","localOptions","ErrorType","EventData","errorName","errorMessage","responseText","responseCode","status","typeDetails","serverErrorName","serverErrorMessage","stack","HTTP_ERROR","errorCode","errorType","getMsg","fromGeneric","eventData","sourceId","resolveTargetUrl","srcFormElement","action","resolveWindowId","requestContext","responseContext","funcName","sourceForm","ajaxType","configId","getCfg","finalEvent","srcElement","resetValues","externalContext","internalContext","elemId","resolveSourceElementId","sourceFormId","forms","req","resolveContexts","resolveResponseXML","responseProcessor","ResponseProcessor","SEL_SUB_TAGS","redirect","ALLOWED_TAGS","processViewState","processClientWindow","storeState","cdataBlock","replaceViewRoot","replaceHead","replaceBody","addToHead","update","handleElementUpdate","processUpdateTag","eval","insertWithSubtags","insert","processInsert","processChangesTag","processPartialTag","fixViewStates","fixClientWindow","shadowDocument","shadowHead","storeForEval","newElements","shadowBody","shadowInnerHTML","resultingBody","updateForms","storeForPostProcessing","mergedErrorData","hasResponseXML","fromServerError","triggerOnError","redirectUrl","before","after","insertNodes","insertId","isViewStateNode","state","StateHolder","isClientWindowNode","updateElems","affectedForms","affectedForms2","appendViewStateToForms","appendClientWindowToForms","createFromRequest","eventHandler","viewState","assignState","newViewStateElement","newViewState","toBeEvaled","storeForUpdate","storeForHeadEval","separatorChar","executes","partialIds","isMultipartRequest","assignEncodedString","applyFormDataToConfig","postInit","getFileInputs","applyViewState","encoded","keyValueEntries","assignString","line","splitToKeyVal","fixKeyWithoutVal","toFormData","appendInputs","resolveSubmitIdentifier","identifier","defaultStr","encodeURIComponent","rootElement","rootFileInputs","childFileInputs","encodeSubmittableFields","targetBuf","parentItem","toEncode","partialIdsArray","xhrObject","XMLHttpRequest","stopProgress","catchFuncs","thenFunc","registerXhrCallbacks","reject","ignoreErr","executesArr","passThroughParams","resolveFinalUrl","setRequestHeader","sendRequest","handleError","abort","inputVal","catchFunc","finally","onabort","onAbort","ontimeout","onTimeout","onload","onSuccess","onloadend","onDone","isCancelledResponse","onError","currentTarget","handleMalFormedXML","isPost","send","evtType","resolveHandlerFunc","responseFormatError","fromHttpConnection","setHiddenInput","formName","input","newInput","clearHiddenInput","submitForm","linkId","clearFn","core","autoScroll","getScrolling","ATTR_TARGET","oldTarget","onsubmit","submit","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__"],"sourceRoot":""}